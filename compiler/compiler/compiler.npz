import math;
import npvec;
import std;

unpack import "./op_codes.npz";
unpack import "./value.npz";

unpack import "../nodes/func_nodes.npz";

class Local {
    let pub name;
    let pub depth;
    let pub loopDepth;
    let pub fixed;
    let pub isCaptured;

    build(name, depth) {
        this.name = name;
        this.depth = depth;

        loopDepth = 0;
        fixed = false;
        isCaptured = false;
    }
}

class Chunk {
    let pub constants;

    let pub bytes;
    let pub count;

    let pub lines;
    let pub linesRun;

    build() {
        bytes = npvec.vec();
        count = 0;

        lines = npvec.vec();
        linesRun = npvec.vec();
        constants = npvec.vec();
    }

    func pub writeByte(b, line) {
        if (npvec.size(lines) > 0 && npvec.at(lines, -1) == line) {
            npvec.set(linesRun, npvec.at(linesRun, -1) + 1, -1);
        } else {
            npvec.append(lines, line);
            npvec.append(linesRun, 1);
        }

        npvec.append(bytes, b);
        count += 1;
    }

    func pub writeBytes(b1, b2, line) {
        writeByte(b1, line);
        writeByte(b2, line);
    }

    func pub addConstant(val) {
        let idx = npvec.find(constants, val);
        if (idx != -1)
            return idx;
        
        npvec.append(constants, val);
        return npvec.size(constants) - 1;
    }

    func pub writeConstant(val, line) {
        const idx = addConstant(val);

        if (idx >= 256) {
            writeByte(OpCode.CONSTANT_LONG, line);
        } else {
            writeByte(OpCode.CONSTANT, line);
        }
        writeByte(idx, line);
    }
}

class Compiler {
    let pub enclosing;

    let prv locals;
    let prv localCount;
    let prv scopeDepth;

    let prv loopDepth;
    let prv breakPatches;

    let pub function;
    let prv type;

    let prv ast;

    let prv lastLine;

    build(name, oType) {
        enclosing = null;

        locals = npvec.vec();
        localCount = 1;
        scopeDepth = 0;

        loopDepth = 0;
        breakPatches = npvec.vec();

        function = Function(Value.String(name));
        type = oType;

        if (type != FuncType.FUNCTION) {
            npvec.append(locals, Local("this", 0));
        } else {
            npvec.append(locals, Local("", 0));
        }

        ast = null;
    }

    func prv emitByte(b, line) {
        if (line == -1)
            line = lastLine;
        else
            lastLine = line;

        function.chunk.writeByte(b, line);
    }

    func prv emitBytes(b1, b2, line) {
        emitByte(b1, line);
        emitByte(b2, line);
    }

    func prv emitReturn(line) {
        if (type == FuncType.BUILDER) {
            emitBytes(OpCode.GET_LOCAL, 0, line);
        } else {
            emitByte(OpCode.NULL, line);
        }

        emitByte(OpCode.RETURN, line);
    }

    func prv emitConstant(val, line) {
        function.chunk.writeConstant(val, line);
    }

    func prv emitJump(op, line) {
        emitByte(op, line);
        emitBytes(0, 0, line);
        return function.chunk.count - 2;
    }

    func prv patchJump(idx) {
        const jump = function.chunk.count - idx - 2;
        npvec.set(
            function.chunk.bytes, 
            math.mod(math.floor(jump / 256), 256),
            idx
        );
        npvec.set(
            function.chunk.bytes, 
            math.mod(jump, 256),
            idx + 1
        );
    }

    func pub compile(tree) {
        ast = tree;
        lastLine = 1;

        compileNode(ast);
    }

    func pub beginScope() {
        scopeDepth += 1;
    }

    func pub endScope() {
        scopeDepth -= 1;

        let popped = 0;
        while (localCount > 0 && npvec.at(locals, -1).depth > scopeDepth) {
            if (npvec.at(locals, -1).isCaptured) {
                emitByte(OpCode.CLOSE_UPVALUE, -1);
            } else {
                emitByte(OpCode.POP, -1);
            }

            localCount -= 1;
        }
    }

    func prv identifierConstant(ident) {
        return function.chunk.addConstant(Value.String(ident));
    }

    func pub addLocal(ident, constant) {
        const local = Local(ident, scopeDepth);
        local.loopDepth = loopDepth;
        local.fixed = constant;
        local.isCaptured = false;

        npvec.append(locals, local);

        localCount += 1;
    }

    func prv resolveLocal(ident) {
        for (let i = localCount - 1; i >= 0; i -= 1) {
            const local = npvec.at(locals, i);
            if (local.name == ident)
                return i;
        }

        return -1;
    }

    func prv compileFunction(fn) {
        const compiler = Compiler(function.name.val, fn.getFuncType());
        compiler.enclosing = this;
        
        const args = fn.getArgs();
        compiler.function.arity = npvec.size(args);
        compiler.beginScope();

        for (let i = 0; i < compiler.function.arity; i += 1)
            compiler.addLocal(npvec.at(args, i), true);
        compiler.compile(fn.getBody());

        compiler.endScope();

        const newFunction = compiler.endCompiler();
        emitByte(OpCode.CLOSURE, fn.getLine());
        emitConstant(Value.Function(newFunction), fn.getLine());

        for (let i = 0; i < newFunction.upvalueCount; i += 1) {
            const upvalue = npvec.at(compiler.upvalues, i);

            if (upvalue.isLocal)
                emitByte(1, -1);
            else
                emitByte(0, -1);
            emitByte(upvalue.index, -1);
        }
    }

    func prv compileNode(node) {
        const nodeType = node.getType();
        if (nodeType == NodeType.BODY) {
            beginScope();
            
            const statements = node.getChildren();
            for (let i = 0; i < npvec.size(statements); i += 1) {
                compileNode(npvec.at(statements, i));
            }

            endScope();
        } 

        // Literals
        else if (nodeType == NodeType.NUMBER) {
            emitConstant(Value.Number(node.getValue()), node.getLine());
        } 
        else if (nodeType == NodeType.BOOLEAN) {
            emitConstant(Value.Bool(node.getValue()), node.getLine());
        } 
        else if (nodeType == NodeType.STRING) {
            emitConstant(Value.String(node.getValue()), node.getLine());
        } 
        else if (nodeType == NodeType.NULL) {
            emitByte(OpCode.NULL, node.getLine());
        } 
        else if (nodeType == NodeType.LIST) {
            const elements = node.getChildren();
            const argc = npvec.size(elements);
            for (let i = 0; i < argc; i += 1)
                compileNode(npvec.at(elements, i));
            emitBytes(OpCode.MAKE_LIST, argc,  -1);
        } 
        
        // Operator Nodes
        else if (nodeType == NodeType.BINARY) {
            compileNode(node.getLeft());
            compileNode(node.getRight());
            emitByte(node.getOpcode(), node.getLine());
        } 
        else if (nodeType == NodeType.UNARY) {
            compileNode(node.getOperand());
            emitByte(node.getOpcode(), node.getLine());
        } 
        else if (nodeType == NodeType.CALL) {
            compileNode(node.getOperand());

            const argc = node.getArgc();
            const args = node.getArgs();
            for (let i = 0; i < argc; i += 1)
                compileNode(npvec.at(args, i));
            
            emitBytes(OpCode.CALL, argc, -1);
        }
        else if (nodeType == NodeType.IMPORT) {
            const constant = identifierConstant(node.getLibrary());
            emitBytes(OpCode.IMPORT, constant, node.getLine());
        }
        else if (nodeType == NodeType.INVOKE) {
            const constant = identifierConstant(node.getName());
            compileNode(node.getOperand());

            const argc = node.getArgc();
            const args = node.getArgs();
            for (let i = 0; i < argc; i += 1)
                compileNode(npvec.at(args, i));
            
            emitBytes(OpCode.INVOKE, constant, -1);
            emitByte(argc, -1);
        }
        else if (nodeType == NodeType.SET_PROPERTY) {
            compileNode(node.getOperand());
            compileNode(node.getValue());

            const constant = identifierConstant(node.getName());
            emitBytes(OpCode.SET_PROPERTY, constant, -1);
        }
        else if (nodeType == NodeType.GET_PROPERTY) {
            compileNode(node.getOperand());

            const constant = identifierConstant(node.getName());
            emitBytes(OpCode.GET_PROPERTY, constant, -1);
        }
        else if (nodeType == NodeType.SET_INDEX) {
            compileNode(node.getOperand());
            compileNode(node.getIndex());
            compileNode(node.getValue());
            emitByte(OpCode.SET_INDEX, -1);
        }
        else if (nodeType == NodeType.AND) {
            compileNode(node.getLeft());
            const jump = emitJump(OpCode.JUMP_IF_FALSE, -1);
            emitByte(OpCode.POP, -1);
            compileNode(node.getRight());
            patchJump(jump);
        }
        else if (nodeType == NodeType.OR) {
            compileNode(node.getLeft());
            const jump = emitJump(OpCode.JUMP_IF_TRUE, -1);
            emitByte(OpCode.POP, -1);
            compileNode(node.getRight());
            patchJump(jump);
        }
        else if (nodeType == NodeType.IMPORT_FILE) {
            emitConstant(Value.String(node.getName()), node.getLine());
            if (node.getAst() == null) {
                emitConstant(Value.String(node.getName()), node.getLine());
                emitByte(OpCode.IMPORT_FILE, node.getLine());
                return;
            }

            const compiler = Compiler(node.getName(), FuncType.SCRIPT);
            compiler.compile(node.getAst());
            const function = compiler.endCompiler();

            emitConstant(Value.Function(function), node.getLine());
            emitByte(OpCode.IMPORT_FILE, node.getLine());
        }
        
        // Variable Nodes
        else if (nodeType == NodeType.DECLARE_GLOBAL) {
            const constant = identifierConstant(node.getName());
            compileNode(node.getValue());
            emitBytes(OpCode.DEFINE_GLOBAL, constant, node.getLine());
        }
        else if (nodeType == NodeType.SET_GLOBAL) {
            const constant = identifierConstant(node.getName());
            compileNode(node.getValue());
            emitBytes(OpCode.SET_GLOBAL, constant, node.getLine());
        }
        else if (nodeType == NodeType.GET_GLOBAL) {
            const constant = identifierConstant(node.getName());
            emitBytes(OpCode.GET_GLOBAL, constant, node.getLine());
        }
        else if (nodeType == NodeType.DECLARE_LOCAL) {
            compileNode(node.getValue());
            addLocal(node.getName(), node.getConstant());
        }
        else if (nodeType == NodeType.SET_LOCAL) {
            const idx = resolveLocal(node.getName());
            compileNode(node.getValue());
            emitBytes(OpCode.SET_LOCAL, idx, node.getLine());
        }
        else if (nodeType == NodeType.GET_LOCAL) {
            const idx = resolveLocal(node.getName());
            emitBytes(OpCode.GET_LOCAL, idx, node.getLine());
        }
        
        // Function Nodes
        else if (nodeType == NodeType.FUNCTION) {
            compileFunction(node);
        }

        else {
            std.println("Unsupported node type '" + std.asString(nodeType) + "'.");
        }

        if (node.emitPop)
            emitByte(OpCode.POP, -1);

        // TODO: Capture upvalues on LOCAL nodes
        // TODO: RETURN node
        // TODO: BREAK node
        // TODO: CONTINUE node
        // TODO: WHILE node
        // TODO: FOR node
        // TODO: CLASS node
        // TODO: THIS node
        // TODO: SUPER node
        // TODO: ATTRIBUTE node
        // TODO: METHOD node
    }

    func pub endCompiler() {
        emitReturn(ast.getEndLine());
        return function;
    }

}
