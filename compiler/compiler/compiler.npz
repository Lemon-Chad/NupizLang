import math;
import npvec;
import npmap;
import std;

unpack import "./op_codes.npz";
unpack import "./value.npz";

unpack import "../nodes/func_nodes.npz";
unpack import "../nodes/class_nodes.npz";

class Local {
    let pub name;
    let pub depth;
    let pub loopDepth;
    let pub fixed;
    let pub isCaptured;

    build(name, depth) {
        this.name = name;
        this.depth = depth;

        loopDepth = 0;
        fixed = false;
        isCaptured = false;
    }
}

class Upvalue {
    let pub idx;
    let pub isLocal;

    build(idx, isLocal) {
        this.idx = idx;
        this.isLocal = isLocal;
    }
}

class CodePoint {
    let pub idx;
    let pub scopeDepth;
    let pub loopDepth;
    
    build(idx, scopeDepth, loopDepth) {
        this.idx = idx;
        this.scopeDepth = scopeDepth;
        this.loopDepth = loopDepth;
    }
}

class Chunk {
    let pub constants;

    let pub bytes;
    let pub count;

    let pub lines;
    let pub linesRun;

    build() {
        bytes = npvec.vec();
        count = 0;

        lines = npvec.vec();
        linesRun = npvec.vec();
        constants = npvec.vec();
    }

    func pub writeByte(b, line) {
        if (npvec.size(lines) > 0 && npvec.at(lines, -1) == line) {
            npvec.set(linesRun, npvec.at(linesRun, -1) + 1, -1);
        } else {
            npvec.append(lines, line);
            npvec.append(linesRun, 1);
        }

        npvec.append(bytes, b);
        count += 1;
    }

    func pub writeBytes(b1, b2, line) {
        writeByte(b1, line);
        writeByte(b2, line);
    }

    func pub addConstant(val) {
        let idx = npvec.find(constants, val);
        if (idx != -1)
            return idx;
        
        npvec.append(constants, val);
        return npvec.size(constants) - 1;
    }

    func pub writeConstant(val, line) {
        const idx = addConstant(val);

        if (idx >= 256) {
            writeByte(OpCode.CONSTANT_LONG, line);
        } else {
            writeByte(OpCode.CONSTANT, line);
        }
        writeByte(idx, line);
    }
}

class Compiler {
    let pub enclosing;

    let pub locals;
    let prv localCount;
    let prv scopeDepth;

    let prv loopPoints;
    let prv loopDepth;
    let prv breakPatches;

    let pub function;
    let prv type;

    let prv ast;

    let prv lastLine;

    let pub upvalues;
    let prv upvalueCount;

    build(name, oType) {
        enclosing = null;

        locals = npvec.vec();
        localCount = 1;
        scopeDepth = 0;

        loopPoints = npvec.vec();
        loopDepth = 0;
        breakPatches = npvec.vec();

        function = Function(Value.String(name));
        type = oType;

        if (type != FuncType.FUNCTION) {
            npvec.append(locals, Local("this", 0));
        } else {
            npvec.append(locals, Local("", 0));
        }

        ast = null;

        upvalues = npvec.vec();
        upvalueCount = 0;
    }

    func prv emitByte(b, line) {
        if (line == -1)
            line = lastLine;
        else
            lastLine = line;

        function.chunk.writeByte(b, line);
    }

    func prv emitBytes(b1, b2, line) {
        emitByte(b1, line);
        emitByte(b2, line);
    }

    func prv emitReturn(line) {
        if (type == FuncType.BUILDER) {
            emitBytes(OpCode.GET_LOCAL, 0, line);
        } else {
            emitByte(OpCode.NULL, line);
        }

        emitByte(OpCode.RETURN, line);
    }

    func prv emitConstant(val, line) {
        function.chunk.writeConstant(val, line);
    }

    func prv emitJump(op, line) {
        emitByte(op, line);
        emitBytes(0, 0, line);
        return function.chunk.count - 2;
    }

    func prv emitLoop(start, line) {
        emitByte(OpCode.LOOP, line);
        const offs = function.chunk.count - start + 2;
        emitBytes(
            math.mod(math.floor(offs / 256), 256),
            math.mod(offs, 256),
            -1
        );
    }

    func prv exitLoop(line) {
        let n = 0;
        for (let i = localCount - 1; i >= 0; i -= 1) {
            if (npvec.at(locals, i).loopDepth < loopDepth)
                break;
            n += 1;
        }
        emitBytes(OpCode.POP_N, n, line);
    }

    func prv patchJump(idx) {
        const jump = function.chunk.count - idx - 2;
        npvec.set(
            function.chunk.bytes, 
            math.mod(math.floor(jump / 256), 256),
            idx
        );
        npvec.set(
            function.chunk.bytes, 
            math.mod(jump, 256),
            idx + 1
        );
    }

    func pub compile(tree) {
        ast = tree;
        lastLine = 1;

        scopeDepth -= 1;
        compileNode(ast);
    }

    func pub beginScope() {
        scopeDepth += 1;
    }

    func pub beginLoop() {
        npvec.append(loopPoints, CodePoint(function.chunk.count, scopeDepth, loopDepth));
        loopDepth += 1;
    }

    func pub endLoop() {
        loopDepth -= 1;
        for (let i = npvec.size(breakPatches) - 1; i >= 0; i -= 1) {
            const patch = npvec.at(breakPatches, i);
            if (patch.loopDepth <= loopDepth)
                break;
            
            patchJump(patch.idx);
            npvec.pop(breakPatches);
        }
    }

    func pub endScope() {
        scopeDepth -= 1;

        while (localCount > 0 && npvec.at(locals, -1).depth > scopeDepth) {
            if (npvec.at(locals, -1).isCaptured) {
                emitByte(OpCode.CLOSE_UPVALUE, -1);
            } else {
                emitByte(OpCode.POP, -1);
            }

            localCount -= 1;
            npvec.pop(locals);
        }
    }

    func prv identifierConstant(ident) {
        return function.chunk.addConstant(Value.String(ident));
    }

    func pub addLocal(ident, constant) {
        const local = Local(ident, scopeDepth);
        local.loopDepth = loopDepth;
        local.fixed = constant;
        local.isCaptured = false;

        npvec.append(locals, local);

        localCount += 1;
    }

    func pub addUpvalue(idx, isLocal) {
        for (let i = 0; i < function.upvalueCount; i += 1) {
            const upvalue = npvec.at(upvalues, i);
            if (upvalue.idx == idx && upvalue.isLocal == isLocal)
                return i;
        }

        const upvalue = Upvalue(idx, isLocal);
        npvec.append(upvalues, upvalue);
        function.upvalueCount = function.upvalueCount + 1;
        return function.upvalueCount - 1;
    }

    func pub resolveLocal(ident) {
        for (let i = localCount - 1; i >= 0; i -= 1) {
            const local = npvec.at(locals, i);
            if (local.name == ident)
                return i;
        }

        return -1;
    }

    func pub resolveUpvalue(ident) {
        if (enclosing == null) return -1;

        const local = enclosing.resolveLocal(ident);
        if (local != -1) {
            npvec.at(enclosing.locals, local).isCaptured = true;
            return addUpvalue(local, true);
        }

        const upvalue = enclosing.resolveUpvalue(ident);
        if (upvalue != -1) {
            return addUpvalue(upvalue, false);
        }

        return -1;
    }

    func prv localVariable(name, line) {
        let idx = resolveLocal(name);
        if (idx == -1) {
            idx = resolveUpvalue(name);
            if (idx == -1)
                return -1;
            
            emitBytes(OpCode.GET_UPVALUE, idx, line);
            return 2;
        } else {
            emitBytes(OpCode.GET_LOCAL, idx, line);
            return 1;
        }

        return -1;
    }

    func prv getVariable(name, line) {
        const res = localVariable(name, line);
        if (res != -1)
            return;
        
        const constant = identifierConstant(name);
        emitBytes(OpCode.GET_GLOBAL, constant, line);
    }

    func prv compileFunction(fn) {
        const compiler = Compiler(function.name.val, fn.getFuncType());
        compiler.enclosing = this;
        
        const args = fn.getArgs();
        compiler.function.arity = npvec.size(args);
        compiler.beginScope();

        for (let i = 0; i < compiler.function.arity; i += 1)
            compiler.addLocal(npvec.at(args, i), true);
        compiler.compile(fn.getBody());

        compiler.endScope();

        const newFunction = compiler.endCompiler();
        emitByte(OpCode.CLOSURE, fn.getLine());
        emitConstant(Value.Function(newFunction), fn.getLine());

        for (let i = 0; i < newFunction.upvalueCount; i += 1) {
            const upvalue = npvec.at(compiler.upvalues, i);

            if (upvalue.isLocal)
                emitByte(1, -1);
            else
                emitByte(0, -1);
            emitByte(upvalue.idx, -1);
        }
    }

    func prv compileNode(node) {
        const nodeType = node.getType();
        if (nodeType == NodeType.BODY) {
            beginScope();
            
            const statements = node.getChildren();
            for (let i = 0; i < npvec.size(statements); i += 1) {
                compileNode(npvec.at(statements, i));
            }

            endScope();
        } 

        // Literals
        else if (nodeType == NodeType.NUMBER) {
            emitConstant(Value.Number(node.getValue()), node.getLine());
        } 
        else if (nodeType == NodeType.BOOLEAN) {
            emitConstant(Value.Bool(node.getValue()), node.getLine());
        } 
        else if (nodeType == NodeType.STRING) {
            emitConstant(Value.String(node.getValue()), node.getLine());
        } 
        else if (nodeType == NodeType.NULL) {
            emitByte(OpCode.NULL, node.getLine());
        } 
        else if (nodeType == NodeType.LIST) {
            const elements = node.getChildren();
            const argc = npvec.size(elements);
            for (let i = 0; i < argc; i += 1)
                compileNode(npvec.at(elements, i));
            emitBytes(OpCode.MAKE_LIST, argc,  -1);
        } 
        
        // Operator Nodes
        else if (nodeType == NodeType.BINARY) {
            compileNode(node.getLeft());
            compileNode(node.getRight());
            emitByte(node.getOpcode(), node.getLine());
        } 
        else if (nodeType == NodeType.UNARY) {
            compileNode(node.getOperand());
            emitByte(node.getOpcode(), node.getLine());
        } 
        else if (nodeType == NodeType.CALL) {
            compileNode(node.getOperand());

            const argc = node.getArgc();
            const args = node.getArgs();
            for (let i = 0; i < argc; i += 1)
                compileNode(npvec.at(args, i));
            
            emitBytes(OpCode.CALL, argc, -1);
        }
        else if (nodeType == NodeType.IMPORT) {
            const constant = identifierConstant(node.getLibrary());
            emitBytes(OpCode.IMPORT, constant, node.getLine());
        }
        else if (nodeType == NodeType.INVOKE) {
            const constant = identifierConstant(node.getName());
            compileNode(node.getOperand());

            const argc = node.getArgc();
            const args = node.getArgs();
            for (let i = 0; i < argc; i += 1)
                compileNode(npvec.at(args, i));
            
            emitBytes(OpCode.INVOKE, constant, -1);
            emitByte(argc, -1);
        }
        else if (nodeType == NodeType.SUPER_INVOKE) {
            getVariable("super", node.getLine());
            
            const name = identifierConstant(node.getName());
            const argc = node.getArgc();
            const args = node.getArgs();
            for (let i = 0; i < argc; i += 1)
                compileNode(npvec.at(args, i));
            
            emitBytes(OpCode.SUPER_INVOKE, name, node.getLine());
            emitByte(argc, -1);
        }
        else if (nodeType == NodeType.SET_PROPERTY) {
            compileNode(node.getOperand());
            compileNode(node.getValue());

            const constant = identifierConstant(node.getName());
            emitBytes(OpCode.SET_PROPERTY, constant, -1);
        }
        else if (nodeType == NodeType.GET_PROPERTY) {
            compileNode(node.getOperand());

            const constant = identifierConstant(node.getName());
            emitBytes(OpCode.GET_PROPERTY, constant, -1);
        }
        else if (nodeType == NodeType.SET_INDEX) {
            compileNode(node.getOperand());
            compileNode(node.getIndex());
            compileNode(node.getValue());
            emitByte(OpCode.SET_INDEX, -1);
        }
        else if (nodeType == NodeType.AND) {
            compileNode(node.getLeft());
            const jump = emitJump(OpCode.JUMP_IF_FALSE, -1);
            emitByte(OpCode.POP, -1);
            compileNode(node.getRight());
            patchJump(jump);
        }
        else if (nodeType == NodeType.OR) {
            compileNode(node.getLeft());
            const jump = emitJump(OpCode.JUMP_IF_TRUE, -1);
            emitByte(OpCode.POP, -1);
            compileNode(node.getRight());
            patchJump(jump);
        }
        else if (nodeType == NodeType.IMPORT_FILE) {
            emitConstant(Value.String(node.getName()), node.getLine());
            if (node.getAst() == null) {
                emitConstant(Value.String(node.getName()), node.getLine());
                emitByte(OpCode.IMPORT_FILE, node.getLine());
                return;
            }

            const compiler = Compiler(node.getName(), FuncType.SCRIPT);
            compiler.compile(node.getAst());
            const function = compiler.endCompiler();

            emitConstant(Value.Function(function), node.getLine());
            emitByte(OpCode.IMPORT_FILE, node.getLine());
        }
        
        // Variable Nodes
        else if (nodeType == NodeType.DECLARE_GLOBAL) {
            const constant = identifierConstant(node.getName());
            compileNode(node.getValue());
            emitBytes(OpCode.DEFINE_GLOBAL, constant, node.getLine());
        }
        else if (nodeType == NodeType.SET_GLOBAL) {
            const constant = identifierConstant(node.getName());
            compileNode(node.getValue());
            emitBytes(OpCode.SET_GLOBAL, constant, node.getLine());
        }
        else if (nodeType == NodeType.GET_GLOBAL) {
            const constant = identifierConstant(node.getName());
            emitBytes(OpCode.GET_GLOBAL, constant, node.getLine());
        }
        else if (nodeType == NodeType.DECLARE_LOCAL) {
            compileNode(node.getValue());
            addLocal(node.getName(), node.getConstant());
        }
        else if (nodeType == NodeType.SET_LOCAL) {
            compileNode(node.getValue());

            let idx = resolveLocal(node.getName());
            if (idx == -1) {
                idx = resolveUpvalue(node.getName());
                emitBytes(OpCode.SET_UPVALUE, idx, node.getLine());
            } else {
                emitBytes(OpCode.SET_LOCAL, idx, node.getLine());
            }
        }
        else if (nodeType == NodeType.GET_LOCAL) {
            localVariable(node.getName(), node.getLine());
        }
        else if (nodeType == NodeType.SUPER) {
            getVariable("super", node.getLine());

            const name = identifierConstant(node.getName());
            emitBytes(OpCode.GET_SUPER, name, node.getLine());
        }
        
        // Function Nodes
        else if (nodeType == NodeType.FUNCTION) {
            compileFunction(node);
        }
        else if (nodeType == NodeType.RETURN) {
            if (node.getValue().getType() == NodeType.NULL) {
                emitReturn(node.getLine());
            } else {
                compileNode(node.getValue());
                emitByte(OpCode.RETURN, -1);
            }
        }

        // Control Nodes
        else if (nodeType == NodeType.IF) {
            compileNode(node.getCondition());

            const thenJump = emitJump(OpCode.JUMP_IF_FALSE, -1);
            emitByte(OpCode.POP, -1);
            compileNode(node.getTrue());

            if (node.getFalse() == null) {
                patchJump(thenJump);
                emitByte(OpCode.POP, -1);
            } else {
                const elseJump = emitJump(OpCode.JUMP, -1);

                patchJump(thenJump);
                emitByte(OpCode.POP, -1);

                compileNode(node.getFalse());
                patchJump(elseJump);
            }
        } 
        else if (nodeType == NodeType.WHILE) {
            beginLoop();

            const start = function.chunk.count;
            compileNode(node.getCondition());

            const exitJump = emitJump(OpCode.JUMP_IF_FALSE, -1);
            emitByte(OpCode.POP, -1);
            compileNode(node.getBody());

            emitLoop(start, -1);

            patchJump(exitJump);
            emitByte(OpCode.POP, -1);

            endLoop();
        }
        else if (nodeType == NodeType.FOR) {
            beginScope();

            if (node.getInitializer() != null)
                compileNode(node.getInitializer());

            let start = function.chunk.count;
            let exitJump = -1;
            if (node.getCondition() != null) {
                compileNode(node.getCondition());
                exitJump = emitJump(OpCode.JUMP_IF_FALSE, -1);
                emitByte(OpCode.POP, -1);
            }

            if (node.getIterator() != null) {
                const bodyJump = emitJump(OpCode.JUMP, node.getIterator().getLine());
                
                beginLoop();
                const incrementStart = function.chunk.count;

                compileNode(node.getIterator());
                emitByte(OpCode.POP, -1);

                emitLoop(start, -1);
                start = incrementStart;
                patchJump(bodyJump);
            } else {
                beginLoop();
            }

            compileNode(node.getBody());
            emitLoop(start, -1);

            if (exitJump != -1) {
                patchJump(exitJump);
                emitByte(OpCode.POP, -1);
            }

            endLoop();
            endScope();
        }
        else if (nodeType == NodeType.BREAK) {
            exitLoop(node.getLine());
            const idx = emitJump(OpCode.JUMP, -1);
            npvec.append(breakPatches, CodePoint(idx, scopeDepth, loopDepth));
        } 
        else if (nodeType == NodeType.CONTINUE) {
            exitLoop(node.getLine());

            const idx = npvec.at(loopPoints, -1).idx;
            emitLoop(idx, -1);
        }

        // Class Nodes
        else if (nodeType == NodeType.CLASS) {
            const name = identifierConstant(node.getName());
            emitBytes(OpCode.CLASS, name, node.getLine());
            if (scopeDepth > 0) {
                addLocal(name, true);
            } else {
                emitBytes(OpCode.DEFINE_GLOBAL, name, node.getLine());
            }

            if (node.getSuper() != null) {
                beginScope();
                addLocal("super", true);

                compileNode(node.getSuper());
                getVariable(node.getName(), node.getSuper().getLine());
                emitByte(OpCode.INHERIT, -1);
            }

            getVariable(node.getName(), -1);

            const fields = node.getFields();
            const fieldKeys = npmap.keys(fields);
            for (let i = 0; i < npvec.size(fieldKeys); i += 1) {
                const field = npmap.get(fields, npvec.at(fieldKeys, i));

                const constant = identifierConstant(field.getName());

                compileNode(field.getValue());

                emitBytes(OpCode.ATTRIBUTE, constant, -1);
                emitBytes(field.getConstant(), field.getPublic(), -1);
                emitByte(field.getStatic(), -1);
            }

            const builder = node.getBuilder();
            if (builder != null) {
                compileNode(builder);
                emitBytes(OpCode.METHOD, 1, builder.getLine());
            }

            const methods = node.getMethods();
            const methodKeys = npmap.keys(methods);
            for (let i = 0; i < npvec.size(methodKeys); i += 1) {
                const method = npmap.get(methods, npvec.at(methodKeys, i));

                let constant;
                if (method.getDefault() == 2) {
                    constant = DefaultMethods.getMapping(method.getName());
                } else {
                    constant = identifierConstant(method.getName());
                }

                compileNode(method.getFunction());
                emitBytes(OpCode.METHOD, method.getDefault(), -1);
                emitByte(constant, -1);
                if (method.getDefault() == 0)
                    emitBytes(method.getPublic(), method.getStatic(), -1);
            }

            emitByte(OpCode.POP, -1);

            if (node.getSuper() != null) 
                endScope();
        }

        else {
            std.println("Unsupported node type '" + std.asString(nodeType) + "'.");
        }

        if (node.emitPop)
            emitByte(OpCode.POP, -1);
    }

    func pub endCompiler() {
        emitReturn(ast.getEndLine());
        return function;
    }

}
