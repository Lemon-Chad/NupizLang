import std;
import npvec;
import npmap;
unpack import "./node.npz";

class DefaultMethods {
    const pub static STRING         =   0;
    const pub static EQ             =   1;
    const pub static HASH           =   2;

    func static getMapping(name) {
        const MAPPING = npmap.map(
            "string",       STRING,
            "eq",           EQ,
            "hash",         HASH
        );

        if (!npmap.has(MAPPING, name))
            return -1;
        return npmap.get(MAPPING, name);
    }

    func static hasMapping(name) {
        return getMapping(name) != -1;
    }
}

class AttrNode <- Node {
    let prv name;
    let prv val;
    let prv isConstant;
    let prv isPrivate;
    let prv isStatic;

    build(oName, oVal, oConstant, oPrivate, oStatic) {
        name = oName;
        val = oVal;
        isConstant = oConstant;
        isPrivate = oPrivate;
        isStatic = oStatic;

        type = NodeType.ATTRIBUTE;
    }

    func getChildren() {
        return npvec.vec(val);
    }

    func def string() {
        let res = "Attr(";
        if (isConstant)
            res += "const ";
        if (isPrivate)
            res += "prv ";
        else
            res += "pub ";
        if (isStatic)
            res += "static ";
        res += name + " = " + std.asString(val);
        return res + ")";
    }

    func pub getName() {
        return name;
    }

    func pub getValue() {
        return val;
    }

    func pub getConstant() {
        if (isConstant)
            return 1;
        return 0;
    }
    
    func pub getPublic() {
        if (isPrivate)
            return 0;
        return 1;
    }
    
    func pub getStatic() {
        if (isStatic)
            return 1;
        return 0;
    }
}

class MethodNode <- Node {
    let prv name;
    let prv function;
    let prv isPrivate;
    let prv isStatic;
    let prv isDefault;

    build(oName, oFunction, oPrivate, oStatic, oDefault) {
        name = oName;
        function = oFunction;
        isPrivate = oPrivate;
        isStatic = oStatic;
        isDefault = oDefault;

        type = NodeType.METHOD;
    }

    func getChildren() {
        return npvec.vec(inner);
    }

    func def string() {
        let res = "Method(";

        if (isDefault)
            res += "def ";
        else if (isPrivate)
            res += "prv ";
        else
            res += "pub ";
        
        if (isStatic)
            res += "static ";
        
        res += name + " = " + std.asString(function);
        return res + ")";
    }

    func pub getName() {
        return name;
    }

    func pub getFunction() {
        return function;
    }

    func pub getDefault() {
        if (isDefault)
            return 2;
        return 0;
    }
    
    func pub getPublic() {
        if (isPrivate)
            return 0;
        return 1;
    }
    
    func pub getStatic() {
        if (isStatic)
            return 1;
        return 0;
    }
}

class ClassNode <- Node {
    let prv name;
    let prv superclass;
    let prv builder;
    let prv methods;
    let prv fields;

    build(oName, oSuperclass, oBuilder, oMethods, oFields) {
        name = oName;
        superclass = oSuperclass;
        builder = oBuilder;
        methods = oMethods;
        fields = oFields;

        type = NodeType.CLASS;
    }

    func getChildren() {
        const children = npvec.vec();
        if (superclass != null)
            npvec.append(children, superclass);
        if (builder != null)
            npvec.append(children, builder);
        
        const methodKeys = npmap.keys(methods);
        for (let i = 0; i < npvec.size(methodKeys); i += 1)
            npvec.append(
                children, 
                npmap.get(
                    methods, 
                    npvec.at(methodKeys, i)
                )
            );
        
        const fieldKeys = npmap.keys(fields);
        for (let i = 0; i < npvec.size(fieldKeys); i += 1)
            npvec.append(
                children, 
                npmap.get(
                    fields, 
                    npvec.at(fieldKeys, i)
                )
            );
        
        return children;
    }

    func pub getName() {
        return name;
    }

    func pub getSuper() {
        return superclass;
    }

    func pub getBuilder() {
        return builder;
    }

    func pub getMethods() {
        return methods;
    }

    func pub getFields() {
        return fields;
    }

    func def string() {
        let res = "Class(" + name;
        if (superclass != null)
            res += " <- " + std.asString(superclass);
        res += "\n";
        
        const fieldKeys = npmap.keys(fields);
        for (let i = 0; i < npvec.size(fieldKeys); i += 1)
            res += "attr -> " + std.asString(npmap.get(
                fields, 
                npvec.at(fieldKeys, i)
            )) + "\n";
        
        if (builder != null)
            res += "builder -> " + std.asString(builder) + "\n";
        
        const methodKeys = npmap.keys(methods);
        for (let i = 0; i < npvec.size(methodKeys); i += 1)
            res += "method -> " + std.asString(npmap.get(
                methods, 
                npvec.at(methodKeys, i)
            )) + "\n";
        return res + ")";
    }
}
