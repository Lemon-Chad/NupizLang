import std;
import npvec;

unpack import "../compiler/op_codes.npz";
unpack import "./node.npz";

class BinaryNode <- Node {
    let prv left;
    let prv right;
    let prv opCode;

    build(l, r, op) {
        left = l;
        right = r;
        opCode = op;

        type = NodeType.BINARY;
    }

    func getChildren() {
        return npvec.vec(left, right);
    }

    func pub getLeft() {
        return left;
    }

    func pub getRight() {
        return right;
    }

    func pub getOpcode() {
        return opCode;
    }

    func def string() {
        return std.asString(left) + " " +
            OpCode.toString(opCode) + " " +
            std.asString(right);
    }
}

class UnaryNode <- Node {
    let prv operand;
    let prv opCode;

    build(oOperand, op) {
        operand = oOperand;
        opCode = op;

        type = NodeType.UNARY;
    }

    func getChildren() {
        return npvec.vec(left, right);
    }

    func pub getOperand() {
        return operand;
    }
    
    func pub getOpcode() {
        return opCode;
    }

    func def string() {
        return OpCode.toString(opCode) + "(" + std.asString(operand) + ")";
    }
}

class CallNode <- Node {
    let prv operand;
    let prv args;
    let prv argc;

    build(oOperand, oArgs) {
        operand = oOperand;
        args = oArgs;
        argc = npvec.size(args);

        type = NodeType.CALL;
    }

    func getChildren() {
        const res = npvec.vec(operand);
        for (let i = 0; i < argc; i += 1)
            npvec.append(res, npvec.at(args, i));
        return res;
    }

    func pub getOperand() {
        return operand;
    }

    func pub getArgs() {
        return args;
    }

    func pub getArgc() {
        return argc;
    }

    func def string() {
        let res = "Call(" + std.asString(operand) + ", [";
        for (let i = 0; i < argc; i += 1)
            res += std.asString(npvec.at(args, i)) + ", ";
        if (argc > 0)
            res = std.slice(res, 0, -3);
        return res + "])";
    }
}

class InvokeNode <- Node {
    let prv operand;
    let prv name;
    let prv args;
    let prv argc;

    build(oOperand, oName, oArgs) {
        operand = oOperand;
        name = oName;
        args = oArgs;
        argc = npvec.size(args);

        type = NodeType.INVOKE;
    }

    func getChildren() {
        const res = npvec.vec(operand);
        for (let i = 0; i < argc; i += 1)
            npvec.append(res, npvec.at(args, i));
        return res;
    }

    func pub getOperand() {
        return operand;
    }

    func pub getName() {
        return name;
    }

    func pub getArgs() {
        return args;
    }

    func pub getArgc() {
        return argc;
    }

    func def string() {
        let res = "Invoke(" + std.asString(operand) + ", '" + name + "', [";
        for (let i = 0; i < argc; i += 1)
            res += std.asString(npvec.at(args, i)) + ", ";
        if (argc > 0)
            res = std.slice(res, 0, -3);
        return res + "])";
    }
}

class SuperInvokeNode <- Node {
    let prv name;
    let prv args;
    let prv argc;

    build(oName, oArgs) {
        name = oName;
        args = oArgs;
        argc = npvec.size(args);

        type = NodeType.SUPER_INVOKE;
    }

    func getChildren() {
        const res = npvec.vec();
        for (let i = 0; i < argc; i += 1)
            npvec.append(res, npvec.at(args, i));
        return res;
    }

    func pub getName() {
        return name;
    }

    func pub getArgs() {
        return args;
    }

    func pub getArgc() {
        return argc;
    }

    func def string() {
        let res = "SuperInvoke(" + name + "', [";
        for (let i = 0; i < argc; i += 1)
            res += std.asString(npvec.at(args, i)) + ", ";
        if (argc > 0)
            res = std.slice(res, 0, -3);
        return res + "])";
    }
}

class GetPropertyNode <- Node {
    let prv operand;
    let prv name;

    build(oOperand, oName) {
        operand = oOperand;
        name = oName;

        type = NodeType.GET_PROPERTY;
    }

    func getChildren() {
        return npvec.vec(operand);
    }

    func pub getOperand() {
        return operand;
    }

    func pub getName() {
        return name;
    }

    func def string() {
        return "GetProperty(" + std.asString(operand) + 
            ", '" + name + "')";
    }
}

class SetPropertyNode <- Node {
    let prv operand;
    let prv name;
    let prv val;

    build(oOperand, oName, oVal) {
        operand = oOperand;
        name = oName;
        val = oVal;

        type = NodeType.SET_PROPERTY;
    }

    func pub getOperand() {
        return operand;
    }

    func pub getName() {
        return name;
    }

    func pub getValue() {
        return val;
    }

    func getChildren() {
        return npvec.vec(operand, val);
    }

    func def string() {
        return "SetProperty(" + std.asString(operand) + 
            ", '" + name + "', " + std.asString(val) + ")";
    }
}

class SetIndexNode <- Node {
    let prv operand;
    let prv index;
    let prv val;

    build(oOperand, oIndex, oVal) {
        operand = oOperand;
        index = oIndex;
        val = oVal;

        type = NodeType.SET_INDEX;
    }

    func getChildren() {
        return npvec.vec(operand, index, val);
    }

    func pub getOperand() {
        return operand;
    }

    func pub getIndex() {
        return index;
    }

    func pub getValue() {
        return val;
    }

    func def string() {
        return "SetIndex(" + std.asString(operand) + 
            ", " + std.asString(index) + 
            ", " + std.asString(val) + ")";
    }
}

class AndNode <- Node {
    let prv left;
    let prv right;

    build(l, r) {
        left = l;
        right = r;

        type = NodeType.AND;
    }

    func getChildren() {
        return npvec.vec(left, right);
    }

    func pub getLeft() {
        return left;
    }

    func pub getRight() {
        return right;
    }

    func def string() {
        return "And(" + std.asString(left) + 
            ", " + std.asString(right) + ")";
    }
}

class OrNode <- Node {
    let prv left;
    let prv right;

    build(l, r) {
        left = l;
        right = r;

        type = NodeType.OR;
    }

    func getChildren() {
        return npvec.vec(left, right);
    }

    func pub getLeft() {
        return left;
    }

    func pub getRight() {
        return right;
    }

    func def string() {
        return "Or(" + std.asString(left) + 
            ", " + std.asString(right) + ")";
    }
}

class ImportNode <- Node {
    let prv name;

    build(oName) {
        name = oName;

        type = NodeType.IMPORT;
    }

    func pub getLibrary() {
        return name;
    }

    func def string() {
        return "Import(" + name + ")";
    }
}

class ImportFileNode <- Node {
    let prv path;
    let prv ast;

    build(oPath, oAST) {
        path = oPath;
        ast = oAST;

        type = NodeType.IMPORT_FILE;
    }

    func getChildren() {
        return npvec.vec(ast);
    }

    func pub getName() {
        return path;
    }

    func pub getAst() {
        return ast;
    }

    func def string() {
        return "Import('" + path + "')";
    }
}
