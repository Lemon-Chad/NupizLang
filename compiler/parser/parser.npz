import iofile;
import std;
import npvec;
import npmap;

const lexerPkg = import "../lexer/lexer.npz";
const formatPkg = import "../util/formatting.npz";

unpack import "./result.npz";
unpack import "../lexer/token.npz";
unpack import "./conventions.npz";

unpack import "../nodes/func_nodes.npz";
unpack import "../nodes/op_nodes.npz";
unpack import "../nodes/value_nodes.npz";
unpack import "../nodes/var_nodes.npz";
unpack import "../nodes/control_nodes.npz";
unpack import "../nodes/class_nodes.npz";

unpack import "../compiler/op_codes.npz";

unpack import "../typing/types.npz";

class Precedence {
    const pub static NONE           =  0;
    const pub static ASSIGNMENT     =  1;
    const pub static OR             =  2;
    const pub static AND            =  3;
    const pub static EQUALITY       =  4;
    const pub static COMPARISON     =  5;
    const pub static TERM           =  6;
    const pub static FACTOR         =  7;
    const pub static UNARY          =  8;
    const pub static CALL           =  9;
    const pub static PRIMARY        = 10;
}

class Parser {
    const prv staticTyping = false;
    const prv debug = false;

    let prv path;

    let prv previous;
    let prv current;
    let prv tokens;
    let prv idx;
    let prv len;
    let prv rules;

    let prv loopDepth;
    let prv scopeDepth;
    let prv ctxStack;

    let prv importedASTs;

    let prv parsingStack;
    let prv classStack;

    let prv globals;

    build(filePath, toks) {
        path = filePath;
        tokens = toks;
        let burger = 4;
    
        idx = 0;
        len = npvec.size(tokens);
        current = npvec.at(toks, 0);
        previous = null;

        rules = npmap.map(
            TokenType.LPAREN,           [grouping,  call,   Precedence.CALL],
            TokenType.DOT,              [null,      dot,    Precedence.CALL],
            TokenType.MINUS,            [unary,     binary, Precedence.TERM],
            TokenType.PLUS,             [null,      binary, Precedence.TERM],
            TokenType.SLASH,            [null,      binary, Precedence.FACTOR],
            TokenType.STAR,             [null,      binary, Precedence.FACTOR],
            TokenType.BANG,             [unary,     null,   Precedence.NONE],
            TokenType.BANG_EQUAL,       [null,      binary, Precedence.EQUALITY],
            TokenType.EQUAL_EQUAL,      [null,      binary, Precedence.EQUALITY],
            TokenType.GREATER,          [null,      binary, Precedence.COMPARISON],
            TokenType.GREATER_EQUAL,    [null,      binary, Precedence.COMPARISON],
            TokenType.LESS,             [null,      binary, Precedence.COMPARISON],
            TokenType.LESS_EQUAL,       [null,      binary, Precedence.COMPARISON],
            TokenType.IDENTIFIER,       [variable,  null,   Precedence.NONE],
            TokenType.STRING,           [string,    null,   Precedence.NONE],
            TokenType.NUMBER,           [number,    null,   Precedence.NONE],
            TokenType.AND,              [null,      and,    Precedence.AND],
            TokenType.KEYWORD,          [keyword,   null,   Precedence.NONE],
            TokenType.OR,               [null,      or,     Precedence.OR],
            TokenType.LBRACKET,         [list,      index,  Precedence.CALL]
        );

        loopDepth = 0;
        scopeDepth = 0;
        ctxStack = npvec.vec();

        importedASTs = npmap.map();

        parsingStack = npvec.vec(FuncType.SCRIPT);

        classStack = npvec.vec();

        globals = npmap.map();
    }

    func prv beginScope() {
        scopeDepth += 1;
        npvec.append(ctxStack, npmap.map());
    }

    func prv endScope() {
        scopeDepth -= 1;
        npvec.pop(ctxStack);
    }

    func prv resolveLocal(name) {
        const height = npvec.size(ctxStack);
        for (let i = height - 1; i >= 0; i -= 1)
            if (npmap.has(npvec.at(ctxStack, i), name))
                return true;
        return false;
    }

    func prv declareLocal(name) {
        if (scopeDepth == 0) return;

        npmap.emplace(npvec.at(ctxStack, -1), name, null);
    }

    func prv updateTok() {
        previous = current;
        if (0 <= idx && idx < len)
            current = npvec.at(tokens, idx);
    }

    func prv advance() {
        idx += 1;
        updateTok();
    }

    func prv peek(dist) {
        if (0 <= idx + dist && idx + dist < len)
            return npvec.at(tokens, idx + dist);
        return null;
    }

    func prv reverse(dist) {
        idx -= dist;
        updateTok();
    }

    func prv match(type, text) {
        if (current.tokenType == type && (text == null || current.text == text)) {
            advance();
            return true;
        }

        return false;
    }

    func pub inheritASTs(asts) {
        const keys = npmap.keys(asts);
        for (let i = 0; i < npvec.size(keys); i += 1) {
            const key = npvec.at(keys, i);
            npmap.emplace(importedASTs, key, npmap.get(asts, key));
        }
    }

    func pub parse() {
        const res = ParseResult();
        const nodes = npvec.vec();

        const ast = BodyNode(nodes);
        npmap.emplace(importedASTs, path, ast);

        const start = current;

        while (idx < len && current.tokenType != TokenType.EOF) {
            const node = res.register(declaration());
            if (res.hasError())
                return res;
            npvec.append(nodes, node);
        }

        if (current.tokenType != TokenType.EOF) {
            return res.failure(Error.ExpectedCharError(
                tokens[-1].filename, tokens[-1].src,
                tokens[-1].idx, tokens[-1].len,
                "Expected end of file."
            ));
        }

        return res.success(
            ast.tokSource(start, current)
        );
    }

    func prv declaration() {
        const res = ParseResult();
        if (match(TokenType.KEYWORD, "var") || 
                match(TokenType.KEYWORD, "let") || 
                match(TokenType.KEYWORD, "const")) {
            res.advance();
            const isConstant = previous.text == "const";
            const node = res.register(varDeclaration(isConstant));
            if (res.hasError())
                return res;
            return res.success(node);
        } else if (match(TokenType.KEYWORD, "func")) {
            res.advance();
            const node = res.register(funDeclaration());
            if (res.hasError())
                return res;
            return res.success(node);
        } else if (match(TokenType.KEYWORD, "class")) {
            res.advance();
            const node = res.register(classDeclaration());
            if (res.hasError())
                return res;
            return res.success(node);
        } else {
            return statement();
        }

        return res.failure(Error.InvalidSyntax(
            current.filename, current.src,
            current.idx, current.len,
            "Expected declaration or statement."
        ));
    }

    func prv declareVariable(name, type, val, isConstant) {
        if (scopeDepth > 0) {
            declareLocal(name);
            return DeclareLocalNode(name, type, val, isConstant);
        }

        return DeclareGlobalNode(name, type, val, isConstant);
    }

    func prv getIdentifier() {
        const res = ParseResult();
        if (!match(TokenType.IDENTIFIER, null))
            return res.failure(Error.InvalidSyntax(
                current.filename, current.src,
                current.idx, current.len,
                "Expected identifier."
            ));
        res.advance();
        const name = previous.text;
        return res.success(name);
    }

    func prv varDeclaration(isConstant) {
        const res = ParseResult();

        const start = previous;

        const name = res.register(getIdentifier());
        if (res.hasError())
            return res;
        
        const type = res.register(parseHint(TokenType.COLON, "Expected ':' after variable name."));
        if (res.hasError())
            return res;

        let val = NullNode().tokSource(previous, previous);
        if (match(TokenType.EQUAL, null)) {
            res.advance();
            val = res.register(expression());
            if (res.hasError())
                return res;
        }

        if (!match(TokenType.SEMICOLON, null))
            return res.failure(Error.ExpectedCharError(
                current.filename, current.src,
                current.idx, current.len,
                "Expected ';' after declaration."
            ));
        res.advance();

        return res.success(
            declareVariable(name, type, val, isConstant)
                .tokSource(start, previous)
        );
    }

    func prv block() {
        const res = ParseResult();
        const start = previous;
        const nodes = npvec.vec();

        while (current.tokenType != TokenType.EOF && 
                current.tokenType != TokenType.RBRACE) {
            const node = res.register(declaration());
            if (res.hasError())
                return res;
            npvec.append(nodes, node);
        }

        if (!match(TokenType.RBRACE, null))
            return res.failure(Error.ExpectedCharError(
                current.filename, current.src,
                current.idx, current.len,
                "Expected '}' after block."
            ));
        res.advance();

        return res.success(
            BodyNode(nodes)
                .tokSource(start, previous)
        );        
    }
    
    func prv parseHint(token, msg) {
        const res = ParseResult();
        if (!staticTyping) return res.success(null);

        if (!match(token, null))
            return res.failure(Error.InvalidSyntax(
                current.filename, current.src,
                current.idx, current.len,
                msg
            ));
        res.advance();
        
        const type = res.register(parseType());
        if (res.hasError())
            return res;
        return res.success(type);
    }

    func prv parseType() {
        const res = ParseResult();
        if (!staticTyping) return res.success(null); 

        const path = npvec.vec();
        while (true) {
            if (!match(TokenType.IDENTIFIER, null))
                return res.failure(Error.InvalidSyntax(
                    current.filename, current.src,
                    current.idx, current.len,
                    "Expected type name or path."
                ));
            res.advance();
            npvec.append(path, previous.text);
            
            if (!match(TokenType.DOT, null))
                break;
            res.advance();
        }

        const args = npvec.vec();
        if (match(TokenType.LESS, null)) {
            res.advance();

            while (true) {
                const arg = res.register(parseType());
                if (res.hasError())
                    return res;
                
                npvec.append(args, arg);
                if (!match(TokenType.COMMA, null))
                    break;
                res.advance();
            }

            if (!match(TokenType.GREATER, null))
                return res.failure(Error.InvalidSyntax(
                    current.filename, current.src,
                    current.idx, current.len,
                    "Expected closing '>' for type arguments."
                ));
            res.advance();
        }

        let nullable = false;
        if (match(TokenType.QUESTION_MARK, null)) {
            res.advance();
            nullable = true;
        }

        return res.success(UnresolvedType(path, args, nullable));
    }

    func prv function(funcType) {
        const res = ParseResult();

        beginScope();
        npvec.append(parsingStack, funcType);
        declareLocal("this");

        const args = npvec.vec();
        if (!match(TokenType.LPAREN, null))
            return res.failure(Error.ExpectedCharError(
                current.filename, current.src,
                current.idx, current.len,
                "Expected '(' before function arguments."
            ));
        res.advance();

        while (current.tokenType != TokenType.RPAREN) {
            const isConstant = match(TokenType.KEYWORD, "const");
            if (isConstant)
                res.advance();
            
            const argName = res.register(getIdentifier());
            if (res.hasError())
                return res;
            
            const typeName = res.register(parseHint(
                TokenType.COLON, 
                "Expected ':' after parameter declaration."
            ));
            if (res.hasError())
                return res;

            npvec.append(args, UnresolvedIdentifier(argName, typeName));
            declareLocal(argName);

            if (!match(TokenType.COMMA, null))
                break;
            res.advance();
        }

        if (!match(TokenType.RPAREN, null))
            return res.failure(Error.ExpectedCharError(
                current.filename, current.src,
                current.idx, current.len,
                "Expected ')' after function arguments."
            ));
        res.advance();

        let returnType = UnresolvedType(
            npvec.vec("void"), npvec.vec(), 
            false
        );
        if (staticTyping && match(TokenType.RIGHT_ARROW, null)) {
            res.advance();
            returnType = res.register(parseType());
            if (res.hasError())
                return res;
        }

        if (match(TokenType.BIG_ARROW, null)) {
            res.advance();

            const returnValue = res.register(expressionStatement());
            if (res.hasError())
                return res;
            returnValue.emitPop = false;

            endScope();
            npvec.pop(parsingStack);
            return res.success(FuncNode(
                args, returnType,
                ReturnNode(returnValue).setSource(
                    returnValue.filename, returnValue.src,
                    returnValue.idx, returnValue.len
                ), funcType
            ));
        }

        if (!match(TokenType.LBRACE, null))
            return res.failure(Error.ExpectedCharError(
                current.filename, current.src,
                current.idx, current.len,
                "Expected '{' before function body."
            ));
        res.advance();

        const body = res.register(block());
        if (res.hasError())
            return res;

        endScope();
        npvec.pop(parsingStack);
        
        return res.success(FuncNode(args, returnType, body, funcType));
    }

    func prv funDeclaration() {
        const res = ParseResult();
        const start = previous;

        const name = res.register(getIdentifier());
        if (res.hasError())
            return res;
        
        const fn = res.register(function(FuncType.FUNCTION));
        if (res.hasError())
            return res;
        fn.tokSource(start, previous);

        return res.success(
            declareVariable(
                name, 
                fn.getAsType(), 
                fn, 
                true
            ).tokSource(start, previous)
        );
    }

    func prv parseAttribute() {
        const res = ParseResult();
        const start = previous;
        
        const isConstant = previous.text == "const";

        let isStatic = false;
        let isPrivate = true;

        if (match(TokenType.KEYWORD, "pub")) {
            res.advance();
            isPrivate = false;
        }

        if (isPrivate && match(TokenType.KEYWORD, "prv"))
            res.advance();
        
        if (match(TokenType.KEYWORD, "static")) {
            res.advance();
            isStatic = true;
        }

        const name = res.register(getIdentifier());
        let val = NullNode().tokSource(previous, previous);
        if (match(TokenType.EQUAL, null)) {
            res.advance();
            val = res.register(expression());
            if (res.hasError())
                return res;
        }

        if (!match(TokenType.SEMICOLON, null))
            return res.failure(Error.ExpectedCharError(
                current.filename, current.src,
                current.idx, current.len,
                "Expected ';' after attribute declaration."
            ));
        res.advance();

        return res.success(
            AttrNode(name, val, isConstant, isPrivate, isStatic)
                .tokSource(start, previous)
        );
    }

    func prv parseMethod() {
        const res = ParseResult();
        const start = previous;

        let isDefault = false;
        let isPrivate = false;
        let isStatic = false;

        if (match(TokenType.KEYWORD, "def")) {
            isDefault = true;
            res.advance();
        }

        if (!isDefault && 
                match(TokenType.KEYWORD, "prv")) {
            isPrivate = true;
            res.advance();
        }

        if (!isDefault && !isPrivate && 
                match(TokenType.KEYWORD, "pub"))
            res.advance();
        
        if (!isDefault && 
                match(TokenType.KEYWORD, "static")) {
            isStatic = true;
            res.advance();
        }

        const name = res.register(getIdentifier());
        if (res.hasError())
            return res;
        
        if (isDefault && !DefaultMethods.hasMapping(name))
            return res.failure(Error.InvalidSyntax(
                previous.filename, previous.src,
                previous.idx, previous.len,
                "Unknown default method '" + name + "'."
            ));

        const fn = res.register(function(FuncType.METHOD));
        if (res.hasError())
            return res;
        
        fn.tokSource(start, previous);

        return res.success(
            MethodNode(name, fn, isPrivate, isStatic, isDefault)
                .tokSource(start, previous)
        );
    }

    func prv parseBuilder() {
        const res = ParseResult();
        const start = previous;
        const fn = res.register(function(FuncType.BUILDER));
        if (res.hasError())
            return res;
        fn.tokSource(start, previous);
        return res.success(fn);
    }

    func prv classDeclaration() {
        const res = ParseResult();
        const start = previous;

        const name = res.register(getIdentifier());
        if (res.hasError())
            return res;
        
        let superclass;
        if (match(TokenType.LEFT_ARROW, null)) {
            res.advance();
            if (!match(TokenType.IDENTIFIER, null))
                return res.failure(Error.InvalidSyntax(
                    current.filename, current.src,
                    current.idx, current.len,
                    "Expected superclass name."
                ));
            
            res.advance();
            if (name == previous.text)
                return res.failure(Error.InvalidSyntax(
                    previous.filename, previous.src,
                    previous.idx, previous.len,
                    "Class cannot inherit from itself."
                ));
            
            superclass = res.register(variable(false));
            if (res.hasError())
                return res;
                
            beginScope();
            declareLocal("super");
        }

        if (!match(TokenType.LBRACE, null))
            return res.failure(Error.ExpectedCharError(
                current.filename, current.src,
                current.idx, current.len,
                "Expected '{' before class body."
            ));
        res.advance();

        npvec.append(classStack, superclass);

        let builder;
        const methods = npmap.map();
        const fields = npmap.map();
        while (current.tokenType != TokenType.EOF &&
                current.tokenType != TokenType.RBRACE) {
            if (match(TokenType.KEYWORD, "func")) {
                res.advance();
                const method = res.register(parseMethod());
                if (res.hasError())
                    return res;
                
                const success = npmap.emplace(
                    methods,
                    method.getName(), method
                );
                if (!success)
                    return res.failure(Error.InvalidSyntax(
                        method.filename, method.src,
                        method.idx, method.len,
                        "Method has already been declared on this class."
                    ));
            } else if (match(TokenType.KEYWORD, "build")) {
                res.advance();
                let newBuilder = res.register(parseBuilder());
                if (res.hasError())
                    return res;
                
                if (builder != null)
                    return res.failure(Error.InvalidSyntax(
                        newBuilder.filename, newBuilder.src,
                        newBuilder.idx, newBuilder.len,
                        "Class already has a defined constructor."
                    ));
                builder = newBuilder;
            } else if (match(TokenType.KEYWORD, "let") || 
                    match(TokenType.KEYWORD, "var") || 
                    match(TokenType.KEYWORD, "const")) {
                res.advance();
                const attribute = res.register(parseAttribute());
                if (res.hasError())
                    return res;
                
                const success = npmap.emplace(
                    fields,
                    attribute.getName(), attribute
                );
                if (!success)
                    return res.failure(Error.InvalidSyntax(
                        attribute.filename, attribute.src,
                        attribute.idx, attribute.len,
                        "Attribute has already been declared on this class."
                    ));
            } else {
                return res.failure(Error.InvalidSyntax(
                    current.filename, current.src,
                    current.idx, current.len,
                    "Expected field, method, or constructor."
                ));
            }
        }

        npvec.pop(classStack);

        if (!match(TokenType.RBRACE, null))
            return res.failure(Error.ExpectedCharError(
                current.filename, current.src,
                current.idx, current.len,
                "Expected '}' after class body."
            ));
        res.advance();

        if (superclass != null)
            endScope();

        const clazz = ClassNode(
            name, superclass, 
            builder, methods, fields
        ).tokSource(start, previous);

        declareLocal(clazz);
        
        return res.success(
            clazz
                .tokSource(start, previous)
        );
    }

    func prv returnStatement() {
        const res = ParseResult();
        const start = previous;

        if (npvec.at(parsingStack, -1) == FuncType.SCRIPT)
            return res.failure(Error.InvalidSyntax(
                current.filename, current.src, 
                previous.idx, previous.len,
                "Cannot return from outside of a function."
            ));
        
        if (match(TokenType.SEMICOLON, null)) {
            res.advance();
            return res.success(
                ReturnNode(NullNode().tokSource(start, previous))
                    .tokSource(start, previous)
            );
        }

        const val = res.register(expression());
        if (!match(TokenType.SEMICOLON, null))
            return res.failure(Error.ExpectedCharError(
                current.filename, current.src,
                current.idx, current.len,
                "Expected ';' after return statement."
            ));

        if (npvec.at(parsingStack, -1) == FuncType.BUILDER)
            return res.failure(Error.InvalidSyntax(
                current.filename, current.src, 
                start.idx, previous.len + previous.idx - start.idx,
                "Cannot return value from constructor."
            ));
        
        res.advance();
        return res.success(
            ReturnNode(val)
                .tokSource(start, previous)
        );
    }

    func prv ifStatement() {
        const res = ParseResult();
        const start = previous;
        if (!match(TokenType.LPAREN, null))
            return res.failure(Error.ExpectedCharError(
                current.filename, current.src,
                current.idx, current.len,
                "Expected '(' before condition."
            ));
        
        res.advance();
        const condition = res.register(expression());
        if (res.hasError())
            return res;
        
        if (!match(TokenType.RPAREN, null))
            return res.failure(Error.ExpectedCharError(
                current.filename, current.src,
                current.idx, current.len,
                "Expected '(' after condition."
            ));
        
        res.advance();
        const ifTrue = res.register(statement());
        if (res.hasError())
            return false;
        
        let ifFalse;
        if (match(TokenType.KEYWORD, "else")) {
            res.advance();
            ifFalse = res.register(statement());
            if (res.hasError())
                return res;
        }

        return res.success(
            IfNode(condition, ifTrue, ifFalse)
                .tokSource(start, previous)
        );
    }

    func prv whileStatement() {
        const res = ParseResult();
        const start = previous;

        if (!match(TokenType.LPAREN, null))
            return res.failure(Error.ExpectedCharError(
                current.filename, current.src,
                current.idx, current.len,
                "Expected '(' before loop condition."
            ));
        res.advance();

        const condition = res.register(expression());
        if (res.hasError())
            return res;
        
        if (!match(TokenType.RPAREN, null))
            return res.failure(Error.ExpectedCharError(
                current.filename, current.src,
                current.idx, current.len,
                "Expected ')' after loop condition."
            ));
        res.advance();

        loopDepth += 1;

        const body = res.register(statement());
        if (res.hasError())
            return res;
        
        loopDepth -= 1;

        return res.success(
            WhileNode(condition, body)
                .tokSource(start, previous)
        );
    }

    func prv forStatement() {
        const res = ParseResult();
        const start = previous;
        beginScope();

        if (!match(TokenType.LPAREN, null))
            return res.failure(Error.ExpectedCharError(
                current.filename, current.src,
                current.idx, current.len,
                "Expected '(' before loop initializer."
            ));
        res.advance();

        let initializer;
        if (match(TokenType.KEYWORD, "var") || match(TokenType.KEYWORD, "let")) {
            res.advance();
            initializer = res.register(varDeclaration(false));
        } else if (!match(TokenType.SEMICOLON, null)) {
            initializer = res.register(expressionStatement());
        } else {
            res.advance();
        }

        if (res.hasError())
            return res;
        
        let condition;
        if (!match(TokenType.SEMICOLON, null)) {
            condition = res.register(expression());
            if (res.hasError())
                return res;
            if (!match(TokenType.SEMICOLON, null))
                return res.failure(Error.ExpectedCharError(
                    current.filename, current.src,
                    current.idx, current.len,
                    "Expected ';' after loop condition."
                ));
        }
        res.advance();

        let iterator;
        if (!match(TokenType.RPAREN, null)) {
            iterator = res.register(expression());
            if (res.hasError())
                return res;
            if (!match(TokenType.RPAREN, null))
                return res.failure(Error.ExpectedCharError(
                    current.filename, current.src,
                    current.idx, current.len,
                    "Expected ')' after loop iterator."
                ));
        }
        res.advance();

        loopDepth += 1;

        const body = res.register(statement());
        if (res.hasError())
            return res;
        
        endScope();
        
        loopDepth -= 1;

        return res.success(
            ForNode(initializer, condition, iterator, body)
                .tokSource(start, previous)
        );
    }

    func prv statement() {
        const res = ParseResult();
        if (match(TokenType.KEYWORD, "return")) {
            res.advance();
            const node = res.register(returnStatement());
            if (res.hasError())
                return res;
            return res.success(node);
        } else if (match(TokenType.KEYWORD, "if")) {
            res.advance();
            const node = res.register(ifStatement());
            if (res.hasError())
                return res;
            return res.success(node);
        } else if (match(TokenType.KEYWORD, "while")) {
            res.advance();
            const node = res.register(whileStatement());
            if (res.hasError())
                return res;
            return res.success(node);
        } else if (match(TokenType.KEYWORD, "for")) {
            res.advance();
            const node = res.register(forStatement());
            if (res.hasError())
                return res;
            return res.success(node);
        } else if (match(TokenType.KEYWORD, "break") ||
                match(TokenType.KEYWORD, "continue")) {
            res.advance();

            if (loopDepth == 0)
                return res.failure(Error.InvalidSyntax(
                    previous.filename, previous.src,
                    previous.idx, previous.len,
                    "Cannot " + text + " in non-loop context."
                ));

            const start = previous;
            const text = previous.text;
            if (!match(TokenType.SEMICOLON, null))
                return res.failure(Error.ExpectedCharError(
                    current.filename, current.src,
                    current.idx, current.len,
                    "Expected ';' after " + text + " statement."
                ));
            res.advance();

            if (text == "break")
                return res.success(
                    BreakNode().tokSource(start, previous)
                );
            return res.success(
                ContinueNode().tokSource(start, previous)
            );
        } else if (match(TokenType.LBRACE, null)) {
            res.advance();
            beginScope();
            const node = res.register(block());
            if (res.hasError())
                return res;
            endScope();
            return res.success(node);
        } else {
            return expressionStatement();
        }

        return ParseResult().failure(Error.InvalidSyntax(
            current.filename, current.src,
            current.idx, current.len,
            "Expected a statement."
        ));
    }

    func prv expressionStatement() {
        const res = ParseResult();
        const node = res.register(expression());
        if (res.hasError())
            return res;
        if (!match(TokenType.SEMICOLON, null))
            return res.failure(Error.ExpectedCharError(
                current.filename, current.src,
                current.idx, current.len,
                "Expected ';' after expression."
            ));
        res.advance();
        node.emitPop = true;
        return res.success(node);
    }

    func prv expression() {
        return parsePrecedence(Precedence.ASSIGNMENT);
    }

    func prv getRule(tokenType) {
        if (npmap.has(rules, tokenType))
            return npmap.get(rules, tokenType);
        return [null, null, Precedence.NONE];
    }

    func prv parsePrecedence(prec) {
        const res = ParseResult();
        
        advance(); 
        res.advance();

        const prefixRule = getRule(previous.tokenType)[0];
        if (prefixRule == null)
            return res.failure(Error.InvalidSyntax(
                previous.filename, previous.src,
                previous.idx, previous.len,
                "Expected expression."
            ));
        
        const canAssign = prec <= Precedence.ASSIGNMENT;
        let node = res.register(prefixRule(canAssign));
        if (res.hasError())
            return res;

        while (prec <= getRule(current.tokenType)[2]) {
            advance();
            res.advance();

            const infixRule = getRule(previous.tokenType)[1];
            node = res.register(infixRule(node, canAssign));
            if (res.hasError())
                return res;
        }

        if (canAssign && match(TokenType.EQUAL, null))
            return res.failure(Error.InvalidSyntax(
                previous.filename, previous.src,
                previous.idx, previous.len,
                "Cannot perform assignment here."
            ));
        res.advance();
        
        return res.success(node);
    }

    func prv grouping(canAssign) {
        const res = ParseResult();

        const node = res.register(expression());
        if (res.hasError())
            return res;
        
        if (!match(TokenType.RPAREN, null))
            return res.failure(Error.ExpectedCharError(
                current.filename, current.src,
                current.idx, current.len,
                "Expected ')' after expression."
            ));
        res.advance();
        return res.success(node);
    }

    func prv valueList(terminator, msg) {
        const res = ParseResult();

        let args = npvec.vec();
        while (current.tokenType != terminator) {
            npvec.append(
                args, 
                res.register(expression())
            );

            if (res.hasError())
                return res;
            
            if (!match(TokenType.COMMA, null))
                break;
            res.advance();
        }

        if (!match(terminator, null))
            return res.failure(Error.ExpectedCharError(
                current.filename, current.src,
                current.idx, current.len,
                msg
            ));
        res.advance();
        return res.success(args);
    }

    func prv argumentList() {
        return valueList(TokenType.RPAREN, "Expected ')' after arguments.");
    }

    func prv call(left, canAssign) {
        const res = ParseResult();

        const args = res.register(argumentList());
        if (res.hasError())
            return res;
        
        return res.success(
            CallNode(left, args).setSource(
                current.filename, current.src, left.idx, 
                previous.idx + previous.len - left.idx
            )
        );
    }

    func prv dot(left, canAssign) {
        const res = ParseResult();

        if (!match(TokenType.IDENTIFIER, null))
            return res.failure(Error.InvalidSyntax(
                current.filename, current.src,
                current.idx, current.len,
                "Expected property name after '.'."
            ));
        res.advance();

        const name = previous.text;
        if (canAssign && match(TokenType.EQUAL, null)) {
            res.advance();
            const node = res.register(expression());
            if (res.hasError())
                return res;
            return res.success(
                SetPropertyNode(left, name, node).setSource(
                    left.filename, left.src, left.idx,
                    previous.idx + previous.len - left.idx
                )
            );
        } else if (match(TokenType.LPAREN, null)) {
            res.advance();
            const args = res.register(argumentList());
            if (res.hasError())
                return res;
            return res.success(
                InvokeNode(left, name, args).setSource(
                    left.filename, left.src, left.idx,
                    previous.idx + previous.len - left.idx
                )
            );
        }

        return res.success(
            GetPropertyNode(left, name).setSource(
                left.filename, left.src, left.idx,
                previous.idx + previous.len - left.idx
            )
        );
    }

    func prv unary(canAssign) {
        const res = ParseResult();

        const tok = previous;
        const node = res.register(parsePrecedence(Precedence.UNARY));
        if (res.hasError())
            return res;
        
        let opcode;
        if (tok.tokenType == TokenType.MINUS)
            opcode = OpCode.NEGATE;
        else if (tok.tokenType == TokenType.BANG)
            opcode = OpCode.NOT;
        else if (tok.tokenType == TokenType.KEYWORD && tok.text == "unpack")
            opcode = OpCode.UNPACK;
        
        return res.success(
            UnaryNode(node, opcode).tokSource(tok, previous)
        );
    }

    func prv binary(left, canAssign) {
        const res = ParseResult();

        const tok = previous;
        const prec = getRule(tok.tokenType)[2];
        const right = res.register(parsePrecedence(prec + 1));
        if (res.hasError())
            return res;
        
        let opcode;
        if (tok.tokenType == TokenType.PLUS)
            opcode = OpCode.ADD;
        if (tok.tokenType == TokenType.MINUS)
            opcode = OpCode.SUBTRACT;
        if (tok.tokenType == TokenType.STAR)
            opcode = OpCode.MULTIPLY;
        if (tok.tokenType == TokenType.SLASH)
            opcode = OpCode.DIVIDE;
        if (tok.tokenType == TokenType.BANG_EQUAL)
            opcode = OpCode.NOT_EQUAL;
        if (tok.tokenType == TokenType.EQUAL_EQUAL)
            opcode = OpCode.EQUAL;
        if (tok.tokenType == TokenType.GREATER)
            opcode = OpCode.GREATER;
        if (tok.tokenType == TokenType.GREATER_EQUAL)
            opcode = OpCode.GREATER_EQUAL;
        if (tok.tokenType == TokenType.LESS)
            opcode = OpCode.LESS;
        if (tok.tokenType == TokenType.LESS_EQUAL)
            opcode = OpCode.LESS_EQUAL;

        return res.success(
            BinaryNode(left, right, opcode).setSource(
                left.filename, left.src, left.idx,
                right.idx + right.len - left.idx
            )
        );
    }

    func prv variable(canAssign) {
        const res = ParseResult();
        const tok = previous;

        let getter;
        let setter;
        if (resolveLocal(tok.text)) {
            getter = GetLocalNode;
            setter = SetLocalNode;
        } else {
            getter = GetGlobalNode;
            setter = SetGlobalNode;
        }

        let assignmentOp = -2;
        if (canAssign) {
            if (match(TokenType.EQUAL, null))
                assignmentOp = -1;
            else if (match(TokenType.PLUS_EQUAL, null))
                assignmentOp = OpCode.ADD;
            else if (match(TokenType.MINUS_EQUAL, null))
                assignmentOp = OpCode.SUBTRACT;
            else if (match(TokenType.STAR_EQUAL, null))
                assignmentOp = OpCode.MULTIPLY;
            else if (match(TokenType.SLASH_EQUAL, null))
                assignmentOp = OpCode.DIVIDE;
        }

        if (assignmentOp == -2)
            return res.success(
                getter(tok.text)
                    .tokSource(tok, tok)
            );
        res.advance();

        let val = res.register(expression());
        if (res.hasError())
            return res;
        
        if (assignmentOp != -1)
            val = BinaryNode(
                getter(tok.text).tokSource(tok, tok), 
                val, assignmentOp).tokSource(tok, previous);
        
        return res.success(
            setter(tok.text, val)
                .tokSource(tok, previous)
        );
    }

    func prv string(canAssign) {
        return ParseResult().success(
            StringNode(previous.text).tokSource(previous, previous)
        );
    }

    func prv and(left, canAssign) {
        const res = ParseResult();

        const right = res.register(parsePrecedence(Precedence.AND));
        if (res.hasError())
            return res;
        
        return res.success(
            AndNode(left, right).setSource(
                left.filename, left.src, left.idx,
                right.idx + right.len - left.idx
            )
        );
    }

    func prv importFile(path) {
        const res = ParseResult();

        if (npmap.has(importedASTs, path)) {
            return res.success(ImportFileNode(path, null));
        }

        const cwd = iofile.getCWD();

        const fp = iofile.openFile(path, "rb");
        iofile.setCWD(iofile.getFileDirectory(path));

        const filename = formatPkg.getFilename(path);
        const src = iofile.readFile(fp);
        iofile.closeFile(fp);

        const lexer = lexerPkg.Lexer(filename, src);
        const hasError = !lexer.lex();
        if (hasError)
            return res.failure(lexer.getError());
        
        const parser = Parser(path, lexer.getTokens());
        parser.inheritASTs(importedASTs);

        const ast = res.register(parser.parse());
        if (res.hasError())
            return res;

        iofile.setCWD(cwd);
        npmap.emplace(importedASTs, path, ast);
        return res.success(ImportFileNode(path, ast));
    }

    func prv importExpression() {
        const res = ParseResult();
        const start = previous;

        if (match(TokenType.IDENTIFIER, null)) {
            res.advance();
            return res.success(
                ImportNode(previous.text)
                    .tokSource(start, previous)
            );
        }

        if (match(TokenType.STRING, null)) {
            res.advance();
            const end = previous;

            if (!iofile.fileExists(previous.text))
                return res.failure(Error(
                    previous.filename, previous.src,
                    previous.idx, previous.len,
                    "Invalid Path", "File to be imported cannot be located."
                ));
            
            const path = iofile.getAbsPath(previous.text);
            const node = res.register(importFile(path));
            if (res.hasError())
                return res;
            node.tokSource(start, end);
            return res.success(
                node
            );
        }
    }

    func prv keyword(canAssign) {
        const res = ParseResult();
        const tok = previous;
        if (tok.text == "true" || tok.text == "false") {
            return res.success(
                BooleanNode(tok.text == "true")
                    .tokSource(previous, previous)
            );
        } else if (tok.text == "null") {
            return res.success(
                NullNode()
                    .tokSource(previous, previous)
            );
        } else if (tok.text == "unpack") {
            return unary(canAssign);
        } else if (tok.text == "this") {
            if (npvec.size(classStack) == 0)
                return res.failure(Error.InvalidSyntax(
                    previous.filename, previous.src,
                    previous.idx, previous.len,
                    "Cannot use 'this' outside of class context."
                ));
            return variable(false);
        } else if (tok.text == "super") {
            if (npvec.size(classStack) == 0)
                return res.failure(Error.InvalidSyntax(
                    previous.filename, previous.src,
                    previous.idx, previous.len,
                    "Cannot use 'super' outside of class context."
                ));
            if (npvec.at(classStack, -1) == null)
                return res.failure(Error.InvalidSyntax(
                    previous.filename, previous.src,
                    previous.idx, previous.len,
                    "Cannot use 'super' inside a class without a parent."
                ));

            const start = previous;
            
            if (!match(TokenType.DOT, null))
                return res.failure(Error.ExpectedCharError(
                    current.filename, current.src,
                    current.idx, current.len,
                    "Expected '.' after super."
                ));
            res.advance();

            if (!match(TokenType.IDENTIFIER, null))
                return res.failure(Error.ExpectedCharError(
                    current.filename, current.src,
                    current.idx, current.len,
                    "Expected superclass method or attribute name."
                ));
            res.advance();

            const name = previous.text;
            if (match(TokenType.LPAREN, null)) {
                res.advance();
                const args = res.register(argumentList());
                if (res.hasError())
                    return res;
                return res.success(
                    SuperInvokeNode(name, args)
                        .tokSource(start, previous)
                );
            } else {
                return res.success(
                    SuperNode(name)
                        .tokSource(start, previous)
                );
            }
        } else if (tok.text == "import") {
            const node = res.register(importExpression());
            if (res.hasError())
                return res;
            return res.success(node);
        }

        return res.failure(Error.InvalidSyntax(
            previous.filename, previous.src,
            previous.idx, previous.len,
            "Unexpected keyword '" + previous.text + "'."
        ));
    }

    func prv or(left, canAssign) {
        const res = ParseResult();

        const right = res.register(parsePrecedence(Precedence.OR));
        if (res.hasError())
            return res;
        
        return res.success(
            OrNode(left, right).setSource(
                left.filename, left.src, left.idx,
                right.idx + right.len - left.idx
            )
        );
    }

    func prv list(canAssign) {
        const res = ParseResult();

        const start = previous;

        const args = res.register(valueList(TokenType.RBRACKET, "Expected ']' after list."));
        if (res.hasError())
            return res;
        
        return res.success(
            ListNode(args).tokSource(start, previous)
        );
    }

    func prv index(left, canAssign) {
        const res = ParseResult();

        const right = res.register(expression());
        if (res.hasError())
            return res;
        
        if (!match(TokenType.RBRACKET, null))
            return res.failure(Error.ExpectedCharError(
                current.filename, current.src,
                current.idx, current.len,
                "Expected ']' after index."
            ));
        res.advance();
        
        if (canAssign && match(TokenType.EQUAL, null)) {
            res.advance();
            const val = res.register(expression());
            if (res.hasError())
                return res;
            return res.success(
                SetIndexNode(left, right, val).setSource(
                    left.filename, left.src, left.idx,
                    val.idx + val.len - left.idx
                )
            );
        }
        
        return res.success(
            BinaryNode(left, right, OpCode.GET_INDEX).setSource(
                left.filename, left.src, left.idx,
                right.idx + right.len - left.idx
            )
        );
    }
    
    func prv number(canAssign) {
        return ParseResult().success(
            NumberNode(std.strtod(previous.text)).tokSource(previous, previous)
        );
    }

}
