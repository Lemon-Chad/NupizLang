import std;
const formatPkg = import "../util/formatting.npz";

class Error {
    let pub filename;
    let pub src;
    let pub idx;
    let pub len;

    let pub name;
    let pub desc;

    build(filename, src, idx, len, name, desc) {
        this.filename = filename;
        this.src = src;
        this.idx = idx;
        this.len = len;

        this.name = name;
        this.desc = desc;
    }

    func def string() {
        if (idx == -1 || len == -1) {
            if (filename == null)
                return name + ": " + desc;
            return name + ": " + desc + "\n" + "File " + filename;
        }

        const line = formatPkg.idxToLine(src, idx) + 1;
        return name + ": " + desc + "\n" +
            "File " + filename + ", line " + 
            std.asString(line) + "\n" +
            formatPkg.addMargin(formatPkg.underlineCode(src, idx, len), "  ");
    }

    func static IllegalCharError(filename, src, idx, len, desc) {
        return Error(filename, src, idx, len, "Illegal Character", desc);
    }

    func static ExpectedCharError(filename, src, idx, len, desc) {
        return Error(filename, src, idx, len, "Expected Character", desc);
    }

    func static InvalidSyntax(filename, src, idx, len, desc) {
        return Error(filename, src, idx, len, "Invalid Syntax", desc);
    }
}

class MultiError <- Error {
    let pub filename2;
    let pub src2;
    let pub idx2;
    let pub len2;

    build(filename, src, idx, len, name, desc) {
        this.filename = filename;
        this.src = src;
        this.idx = idx;
        this.len = len;

        this.name = name;
        this.desc = desc;
    }

    func pub setSecond(filename2, src2, idx2, len2) {
        this.filename2 = filename2;
        this.src2 = src2;
        this.idx2 = idx2;
        this.len2 = len2;

        return this;
    }

    func def string() {
        if (idx == -1 || len == -1) {
            if (filename == null)
                return name + ": " + desc;
            return name + ": " + desc + "\n" + "File " + filename;
        }

        const line = formatPkg.idxToLine(src, idx) + 1;
        const line2 = formatPkg.idxToLine(src2, idx2) + 1;

        const header = name + ": " + desc;
        const pos1 = "File " + filename + ", line " +
            std.asString(line) + "\n" +
            formatPkg.addMargin(formatPkg.underlineCode(src, idx, len), "│ ");
        const pos2 = "File " + filename2 + ", line " +
            std.asString(line2) + "\n" +
            formatPkg.addMargin(formatPkg.underlineCode(src2, idx2, len2), "  ");
        

        return header + "\n" +
            pos1 + "\n│\n" +
            pos2;
    }
}

class Tip <- Error {
    let pub tip;

    build(filename, src, idx, len, name, desc, tip) {
        this.filename = filename;
        this.src = src;
        this.idx = idx;
        this.len = len;

        this.name = name;
        this.desc = desc;
        this.tip = tip;
    }

    func def string() {
        if (idx == -1 || len == -1) {
            return name + ": " + desc;
        }

        return super.string() + "\nExample:\n" + tip + "\n";
    }
}

class ParseResult {
    let pub val;
    let pub error;
    let pub advances;
    let pub reverses;

    build() {
        val = null;
        error = null;
        advances = 0;
        reverses = 0;
    }

    func pub advance() {
        advances += 1;
    }

    func pub tryRegister(res) {
        if (res.error != null) {
            error = res.error;
            reverses += res.advances;
            return null;
        }

        return register(res);
    }

    func pub register(res) {
        advances += res.advances;
        if (res.error != null) {
            error = res.error;
        }
        return res.val;
    }

    func pub success(val) {
        this.val = val;
        return this;
    }

    func pub failure(error) {
        if (this.error == null || advances == 0)
            this.error = error;
        return this;
    }

    func pub hasError() {
        return error != null;
    }

    func pub printError() {
        std.println(std.asString(error));
    }
}
