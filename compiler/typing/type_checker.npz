import std;
import npvec;
import npmap;

unpack import "./nptype.npz";

const packagerPkg = import "./type_packager.npz";

const resPkg = import "../parser/result.npz";
const Error = resPkg.Error;
const MultiError = resPkg.MultiError;

const nodePkg = import "../nodes/node.npz";
const NodeType = nodePkg.NodeType;

class TypeResult {
    let pub errors;
    let pub val;

    let pub dependencies;

    build() {
        errors = npvec.vec();
        val = null;

        dependencies = npvec.vec();
    }

    func pub success(val) {
        this.val = val;
        return this;
    }

    func pub register(res) {
        for (let i = 0; i < npvec.size(res.errors); i += 1)
            npvec.append(errors, npvec.at(res.errors, i));
        for (let i = 0; i < npvec.size(res.dependencies); i += 1)
            npvec.append(dependencies, npvec.at(res.dependencies, i));
        return res.val;
    }

    func pub hasError() {
        return npvec.size(errors) > 0;
    }

    func pub addDependency(name) {
        npvec.append(dependencies, name);
    }

    func pub hasDependencies() {
        return npvec.size(dependencies) > 0;
    }

    func pub printErrors() {
        for (let i = 0; i < npvec.size(errors); i += 1)
            std.println(std.asString(npvec.at(errors, i)) + "\n");
    }

    func pub failure(name, desc, node) {
        const error = Error(
            node.getFilename(), node.getSrc(),
            node.getIdx(), node.getLen(),
            name, desc
        );
        npvec.append(errors, error);

        return this;
    }

    func pub multifailure(name, desc, node1, node2) {
        const error = MultiError(
            node1.getFilename(), node1.getSrc(),
            node1.getIdx(), node1.getLen(),
            name, desc
        );
        error.setSecond(
            node2.getFilename(), node2.getSrc(),
            node2.getIdx(), node2.getLen()
        );
        npvec.append(errors, error);

        return this;
    }

    func pub typeFailure(type, node) {
        return failure(type.name, type.desc, node);
    }
}

// Represents a typed variable that
// may hold dependencies on other variables
class TypedVariable {
    let pub name;
    let pub varType;
    let pub isFunction;
    let pub isConstant;
    let pub declNode;

    let pub dependencies;
    let pub dependencyCount;

    let pub visited;

    build(name, varType) {
        this.name = name;
        this.varType = varType;

        this.dependencies = npmap.map();
        this.dependencyCount = 0;
        
        this.isFunction = false;
        this.visited = false;
        this.isConstant = false;
    }

    func pub addDependency(dependency) {
        if (npmap.has(dependency.name))
            return;
        
        dependencyCount += 1;
        npmap.emplace(dependecies, dependency.name, dependency);
    }

    func pub isResolved() {
        if (this.visited)
            return true;
        
        if (varType == null)
            return false;

        this.visited = true;
        for (let i = 0; i < dependencyCount; i += 1) {
            if (!npvec.at(dependencies, i).isResolved()) {
                this.visited = false;
                return false;
            }
        }
        this.visited = false;

        return true;
    }

    func pub resolveDependency(dependency) {
        if (this.visited)
            return;
        
        if (npmap.has(dependencies, dependency.name) && 
                !npmap.get(dependecies, dependency.name)
                    .isResolved())
            npmap.put(dependencies, dependency.name, dependency);
        
        this.visited = true;
        for (let i = 0; i < dependencyCount; i += 1)
            npvec.at(dependecies, i).resolveDependency(dependency);
        this.visited = false;
    }

    func def eq(other) {
        return name == other.name && 
            varType == other.varType;
    }
}

// Represents a function that might be dependent
// on undefined variables. Allows backpatching and
// fixing of such functions when defined, or
// catching undefined global variables early.
class TypedFunction <- TypedVariable {
    let pub args;
    let pub argc;
    let pub returnType;

    let pub body;
    
    build(name, args, returnType, body) {
        this.name = name;
        this.argc = npvec.size(argNames);
        this.args = args;
        this.returnType = returnType;

        const subtypes = npvec.vec();
        for (let i = 0; i < argc; i += 1)
            npvec.append(subtypes, npvec.at(args, i).varType);
        npvec.append(subtypes, returnType);

        this.varType = NPFunction(subtypes);
        this.varType.typedFunction = this;

        this.dependencies = npmap.map();
        this.dependencyCount = 0;

        for (let i = 0; i < this.argc; i += 1)
            addDependency(npvec.at(args, i));

        this.body = body;

        this.isFunction = true;
        this.isConstant = false;
    }
}

class TypeChecker {
    let prv rootPackage;

    // Stack of scopes of current package
    // Used for relative path packaging.
    let prv packageStack;

    // Global variable scopes
    // Holds name: TypedVariable
    let prv globals;

    // Stack of local variable scopes
    // Holds [{ name: TypedVariable }]
    let prv localStack;
    let prv scopeDepth;

    // Holds the stack of all functions currently
    // being defined.
    let prv functionStack;
    let prv functionDepth;

    build(root) {
        rootPackage = root;

        packageStack = npvec.vec(npvec.vec());

        globals = npmap.map();
        localStack = npvec.vec();
        scopeDepth = 0;

        functionStack = npvec.vec();
        functionDepth = 0;
    }

    func pub check(ast) {
        scopeDepth -= 1;
        return visit(ast);
    }

    func pub beginScope() {
        scopeDepth += 1;
        if (scopeDepth > 0)
            npvec.append(localStack, npmap.map());
    }

    func pub endScope() {
        if (scopeDepth > 0)
            npvec.pop(localStack);
        scopeDepth -= 1;
    }

    func pub declareLocal(v) {
        if (scopeDepth == 0)
            return false;
        addDependency(v);
        return npmap.emplace(
            npvec.at(localStack, -1),
            v.name, v
        );
    }

    func pub declareGlobal(v) {
        if (!npmap.emplace(globals, v.name, v))
            return false;
        
        resolveDependency(v);

        return true;
    }

    // func is a TypedFunction
    // Declares all arguments for the function
    // as locals automatically
    func pub beginFunction(fn) {
        beginScope();

        npvec.append(functionStack, fn);
        functionDepth += 1;

        for (let i = 0; i < fn.argc; i += 1)
            declareLocal(npvec.at(fn.args, i));
    }

    // Returns the function
    func pub endFunction() {
        endScope();
        functionDepth -= 1;
        return npvec.pop(functionStack);
    }

    func prv addRelativePath(path) {
        // pack lemon.monad;
        // class Box { ... }
        // let x: Box = Box(4);
        //
        // Box -> lemon.monad.Box;

        const newPath = npvec.vec();

        const toPrepend = npvec.at(packageStack, -1);
        for (let i = 0; i < npvec.size(toPrepend); i += 1)
            npvec.append(newPath, npvec.at(toPrepend, i));
        
        for (let i = 0; i < npvec.size(path); i += 1)
            npvec.append(newPath, npvec.at(path, i));
        
        return newPath;
    }

    func prv visit(node) {
        return visitExpected(node, null);
    }

    func prv visitExpected(node, expected) {
        const nodeType = node.getType();
        if (nodeType == NodeType.PACKAGE) {
            npvec.append(packageStack, node.getPath());
            const res = visit(node.getBody());
            npvec.pop(packageStack);

            return res;
        } 
        else if (nodeType == NodeType.BODY) {
            const res = TypeResult();

            beginScope();

            const nodes = node.getChildren();
            for (let i = 0; i < npvec.size(nodes); i += 1)
                res.register(visit(npvec.at(nodes, i)));
            
            endScope();

            return res;
        }

        // Literals [ ]
        else if (nodeType == NodeType.NUMBER) {
            return TypeResult().success(NPNumber.get());
        }
        else if (nodeType == NodeType.BOOLEAN) {
            std.println(std.asString(NPString.get()));
            return TypeResult().success(NPBoolean.get());
        }
        else if (nodeType == NodeType.NULL) {
            return TypeResult().success(NPVoid.get());
        }
        else if (nodeType == NodeType.STRING) {
            return TypeResult().success(NPString.get());
        }
        else if (nodeType == NodeType.LIST) {
            const res = TypeResult();

            // Cases:
            //
            // Expected list type: list<subtype>
            //  Check all elements to be able to be upcasted
            //  to subtype.
            //  If not, list<any>
            //
            // No list elements
            //  Return list<any>
            //
            // List with elements
            //  Set subtype to type of first element, then
            //  make sure all elements are equivalent. If
            //  not, then list<any>

            const nodes = node.getChildren();

            // Case 1: Expected list type
            if (expected != null && expected.type == NPType.LIST) {
                const subtype = expected.subtype;

                let matchesExpected = true;
                for (let i = 0; i < npvec.size(nodes); i += 1) {
                    const node = npvec.at(nodes, i);
                    const nodeType = res.register(visit(node));
                    if (res.hasError())
                        continue;
                    
                    if (!nodeType.canUpcast(subtype))
                        matchesExpected = false;
                }

                if (res.hasError())
                    return res;
                
                if (matchesExpected)
                    return res.success(expected);
            }

            // Case 2: Matching list element types
            if (npvec.size(nodes) > 0) {
                const nodes = node.getChildren();
                const subtype = res.register(visit(npvec.at(nodes, 0)));
                if (res.hasError())
                    return res;

                let matchesExpected = true;
                for (let i = 1; i < npvec.size(nodes); i += 1) {
                    const node = npvec.at(nodes, i);
                    const nodeType = res.register(visit(node));
                    if (res.hasError())
                        continue;
                    
                    if (nodeType != subtype)
                        matchesExpected = false;
                }

                if (res.hasError())
                    return res;
                
                if (matchesExpected)
                    return res.success(NPList(subtype));
            }
            
            // Case 3: Empty list or default for other cases
            return res.success(NPList(NPAny.get()));
        }

        // Operations [ ]
        else if (nodeType == NodeType.CAST) {
            return typeLookup(node.getCastType());
        }
        else if (nodeType == NodeType.BINARY) {
            const res = TypeResult();
            const leftType = res.register(visit(node.getLeft()));
            const rightType = res.register(visit(node.getRight()));

            if (res.hasError())
                return res;
            
            const opcode = TypeOperations.fromOpcode(node.getOpcode());
            const operation = leftType.operation(opcode);
            const outType = operation(npvec.vec(rightType), 1);
            if (outType.type == NPType.ERROR)
                return res.typeFailure(outType, node.getRight());
            return res.success(outType);
        }
        else if (nodeType == NodeType.UNARY) {
            const res = TypeResult();
            const opType = res.register(visit(node.getOperand()));

            if (res.hasError())
                return res;
            
            const opcode = TypeOperations.fromOpcode(node.getOpcode());
            const operation = opType.operation(opcode);
            const outType = operation(npvec.vec(), 0);
            if (outType.type == NPType.ERROR)
                return res.typeFailure(outType, node.getOperand());
            return res.success(outType);
        }

        // Variables [ ]
        else if (nodeType == NodeType.DECLARE_GLOBAL) {
            const res = TypeResult();

            let varType;
            if (node.getVarType() != null)
                varType = res.register(typeLookup(node.getVarType()));
            
            const valType = res.register(
                visitExpected(
                    node.getValue(), 
                    varType
                )
            );

            if (res.hasError())
                return res;
            
            if (varType == null)
                varType = valType;
            if (!valType.canUpcast(varType))
                return res.failure(
                    "Type Mismatch",
                    "Expected '" + std.asString(varType) + 
                    "', got '" + std.asString(valType) + "'.",
                    node.getValue()
                );
            
            const tvar = TypedVariable(node.getName(), varType);
            tvar.declNode = node;
            tvar.isConstant = node.getConstant();

            if (!declareGlobal(tvar))
                return res.multifailure(
                    "Redeclared Variable",
                    "Global variable '" + node.getName() +
                    "' has been declared previously.",
                    node,
                    npmap.get(globals, tvar.name).declNode
                );
            return res.success(varType);
        }
        else if (nodeType == NodeType.GET_GLOBAL) {
            const res = TypeResult();
            const varType = getTypedGlobal(node.getName());
            if (varType == null)
                return res.failure(
                    "Undefined Variable",
                    "Global variable '" + node.getName() +
                    "' is undefined.",
                    node
                );
            return res.success(varType.varType);
        }
        else if (nodeType == NodeType.SET_GLOBAL) {
            const res = TypeResult();
            const varType = getTypedGlobal(node.getName());
            if (varType == null)
                return res.failure(
                    "Undefined Variable",
                    "Global variable '" + node.getName() +
                    "' is undefined.",
                    node
                );
            const valType = res.register(
                visitExpected(
                    node.getValue(), 
                    varType.varType
                )
            );
            if (res.hasError())
                return res;
            if (!valType.canUpcast(varType.varType))
                return res.failure(
                    "Type Mismatch",
                    "Expected '" + std.asString(varType.varType) +
                    "', got '" + std.asString(valType) + "'.",
                    node.getValue()
                );
            return res.success(varType);
        }
        else if (nodeType == NodeType.DECLARE_LOCAL) {
            const res = TypeResult();

            let varType;
            if (node.getVarType() != null)
                varType = res.register(typeLookup(node.getVarType()));
            
            const valType = res.register(
                visitExpected(
                    node.getValue(), 
                    varType
                )
            );

            if (res.hasError())
                return res;
            
            if (varType == null)
                varType = valType;
            if (!valType.canUpcast(varType))
                return res.failure(
                    "Type Mismatch",
                    "Expected '" + std.asString(varType) + 
                    "', got '" + std.asString(valType) + "'.",
                    node.getValue()
                );
            
            const tvar = TypedVariable(node.getName(), varType);
            tvar.declNode = node;
            tvar.isConstant = node.getConstant();

            if (!declareLocal(tvar))
                return res.multifailure(
                    "Redeclared Variable",
                    "Local variable '" + node.getName() +
                    "' has been declared previously.",
                    node,
                    npmap.get(npvec.at(localStack, -1), tvar.name).declNode
                );
            return res.success(varType);
        }
        else if (nodeType == NodeType.GET_LOCAL) {
            const res = TypeResult();
            const varType = getTypedLocal(node.getName());
            if (varType == null)
                return res.failure(
                    "Undefined Variable",
                    "Local variable '" + node.getName() +
                    "' is undefined.",
                    node
                );
            return res.success(varType.varType);
        }
        else if (nodeType == NodeType.SET_LOCAL) {
            const res = TypeResult();
            const varType = getTypedLocal(node.getName());
            if (varType == null)
                return res.failure(
                    "Undefined Variable",
                    "Local variable '" + node.getName() +
                    "' is undefined.",
                    node
                );
            const valType = res.register(
                visitExpected(
                    node.getValue(), 
                    varType.varType
                )
            );
            if (res.hasError())
                return res;
            if (!valType.canUpcast(varType.varType))
                return res.failure(
                    "Type Mismatch",
                    "Expected '" + std.asString(varType.varType) +
                    "', got '" + std.asString(valType) + "'.",
                    node.getValue()
                );
            return res.success(varType);
        }

        // Functions [ ]

        // Control Flow [ ]
        
        // Classes

        return TypeResult().success(NPVoid.get());
    }

    func prv typeLookup(unres) {
        return TypeResult().success(rootPackage.typeLookup(unres));
    }

    func prv addDependency(v) {
        if (functionDepth == 0)
            return;
        npvec.at(functionDepth, -1).addDependency(v);
    }

    func prv resolveDependency(v) {
        const keys = npmap.keys(globals);
        for (let i = 0; i < npvec.size(keys); i += 1)
            npmap.get(globals, npvec.at(keys, i))
                .resolveDependency(v);
    }

    func prv isResolved() {
        const keys = npmap.keys(globals);
        for (let i = 0; i < npvec.size(keys); i += 1)
            if (!npmap.get(globals, npvec.at(keys, i))
                    .isResolved())
                return false;
        return true;
    }

    func prv getTypedLocal(name) {
        for (let i = scopeDepth - 1; i >= 0; i += 1) {
            const localScope = npvec.at(localStack, i);
            if (npmap.has(localScope, name)) {
                const typedVariable = npmap.get(localScope, name);
            
                addDependency(typedVariable);

                return typedVariable;
            }
        }

        return null;
    }

    func prv getTypedGlobal(name) {
        if (npmap.has(globals, name)) {
            const typedVariable = npmap.get(globals, name);

            addDependency(typedVariable);
            
            return typedVariable;
        }

        return null;
    }

    func prv getTypedVariable(name) {
        const loc = getTypedLocal(name);
        if (loc != null)
            return loc;

        return getTypedGlobal(name);
    }
}
