import std;
import npvec;
import npmap;

unpack import "./nptype.npz";

const packagerPkg = import "./type_packager.npz";

const resPkg = import "../parser/result.npz";
const Error = resPkg.Error;

const nodePkg = import "../nodes/node.npz";
const NodeType = nodePkg.NodeType;

class TypeResult {
    let pub errors;
    let pub val;

    let pub dependencies;

    build() {
        errors = npvec.vec();
        val = null;

        dependencies = npvec.vec();
    }

    func pub success(val) {
        this.val = val;
        return this;
    }

    func pub register(res) {
        for (let i = 0; i < npvec.size(res.errors); i += 1)
            npvec.append(errors, npvec.at(res.errors, i));
        for (let i = 0; i < npvec.size(res.dependencies); i += 1)
            npvec.append(dependencies, npvec.at(res.dependencies, i));
        return res.val;
    }

    func pub hasError() {
        return npvec.size(errors) > 0;
    }

    func pub addDependency(name) {
        npvec.append(dependencies, name);
    }

    func pub hasDependencies() {
        return npvec.size(dependencies) > 0;
    }

    func pub printErrors() {
        for (let i = 0; i < npvec.size(errors); i += 1)
            std.println(std.asString(npvec.at(errors, i)));
    }

    func pub failure(name, desc, node) {
        const error = Error(
            node.getFilename(), node.getSrc(),
            node.getIdx(), node.getLen(),
            name, desc
        );
        npvec.append(errors, error);

        return this;
    }

    func pub typeFailure(type, node) {
        return failure(type.name, type.desc, node);
    }
}

// Represents a typed variable that
// may hold dependencies on other variables
class TypedVariable {
    let pub name;
    let pub varType;
    let pub isFunction;

    let pub dependencies;
    let pub dependencyCount;

    let pub visited;

    build(name, varType) {
        this.name = name;
        this.varType = varType;

        this.dependencies = npmap.map();
        this.dependencyCount = 0;
        
        this.isFunction = false;
        this.visited = false;
    }

    func pub addDependency(dependency) {
        if (npmap.has(dependency.name))
            return;
        
        dependencyCount += 1
        npmap.emplace(dependecies, dependency.name, dependency);
    }

    func pub isResolved() {
        if (this.visited)
            return true;
        
        if (varType == null)
            return false;

        this.visited = true;
        for (let i = 0; i < dependencyCount; i += 1) {
            if (!npvec.at(dependencies, i).isResolved()) {
                this.visited = false;
                return false;
            }
        }
        this.visited = false;

        return true;
    }

    func pub resolveDependency(dependency) {
        if (this.visited)
            return;
        
        if (npmap.has(dependency.name) && 
                !npmap.get(dependecies, dependency.name)
                    .isResolved())
            npmap.put(dependencies, dependency.name, dependency);
        
        this.visited = true;
        for (let i = 0; i < dependencyCount; i += 1)
            npvec.at(dependecies, i).resolveDependency(dependency);
        this.visited = false;
    }
}

// Represents a function that might be dependent
// on undefined variables. Allows backpatching and
// fixing of such functions when defined, or
// catching undefined global variables early.
class TypedFunction <- TypedVariable {
    let pub argNames;
    let pub argTypes;
    let pub argc;
    let pub returnType;

    let pub body;
    
    build(name, argNames, argTypes, returnType, body) {
        this.name = name;
        this.argc = npvec.size(argNames);
        this.argNames = argNames;
        this.argTypes = argTypes;
        this.returnType = returnType;

        const subtypes = npvec.vec();
        for (let i = 0; i < argc; i += 1)
            npvec.append(subtypes, npvec.at(argTypes, i));
        npvec.append(subtypes, returnType);

        this.varType = NPFunction(subtypes);

        this.dependencies = npmap.map();
        this.dependencyCount = 0;

        for (let i = 0; i < this.argc; i += 1) {
            addDependency(TypedVariable(
                npvec.at(argNames, i),
                npvec.at(argTypes, i)
            ));
        }

        this.body = body;

        this.isFunction = true;
    }
}

class TypeChecker {
    let prv rootPackage;

    // Stack of scopes of current package
    // Used for relative path packaging.
    let prv packageStack;

    // Global variable scopes
    // Holds name: TypedVariable
    let prv globals;

    // Stack of local variable scopes
    // Holds [{ name: TypedVariable }]
    let prv localStack;
    let prv scopeDepth;

    // Holds the stack of all functions currently
    // being defined.
    let prv functionStack;
    let prv functionDepth;

    build(root) {
        rootPackage = root;

        packageStack = npvec.vec(npvec.vec());

        globals = npmap.map();
        localStack = npvec.vec();
        scopeDepth = 0;

        functionStack = npvec.vec();
        functionDepth = 0;
    }

    func pub check(ast) {
        return visit(ast);
    }

    func prv addRelativePath(path) {
        // pack lemon.monad;
        // class Box { ... }
        // let x: Box = Box(4);
        //
        // Box -> lemon.monad.Box;

        const newPath = npvec.vec();

        const toPrepend = npvec.at(packageStack, -1);
        for (let i = 0; i < npvec.size(toPrepend); i += 1)
            npvec.append(newPath, npvec.at(toPrepend, i));
        
        for (let i = 0; i < npvec.size(path); i += 1)
            npvec.append(newPath, npvec.at(path, i));
        
        return newPath;
    }

    func prv visit(node) {
        return visitExpected(node, null);
    }

    func prv visitExpected(node, expected) {
        const nodeType = node.getType();
        if (nodeType == NodeType.PACKAGE) {
            npvec.append(packageStack, node.getPath());
            const res = visit(node.getBody());
            npvec.pop(packageStack);

            return res;
        } 
        else if (nodeType == NodeType.BODY) {
            const res = TypeResult();
            const nodes = node.getChildren();
            for (let i = 0; i < npvec.size(nodes); i += 1)
                res.register(visit(npvec.at(nodes, i)));
            return res;
        }

        // Literals [ ]
        else if (nodeType == NodeType.NUMBER) {
            return TypeResult().success(NPNumber.get());
        }
        else if (nodeType == NodeType.BOOLEAN) {
            std.println(std.asString(NPString.get()));
            return TypeResult().success(NPBoolean.get());
        }
        else if (nodeType == NodeType.NULL) {
            return TypeResult().success(NPVoid.get());
        }
        else if (nodeType == NodeType.STRING) {
            return TypeResult().success(NPString.get());
        }
        else if (nodeType == NodeType.LIST) {
            const res = TypeResult();

            // Cases:
            //
            // Expected list type: list<subtype>
            //  Check all elements to be able to be upcasted
            //  to subtype.
            //  If not, list<any>
            //
            // No list elements
            //  Return list<any>
            //
            // List with elements
            //  Set subtype to type of first element, then
            //  make sure all elements are equivalent. If
            //  not, then list<any>

            const nodes = node.getChildren();

            // Case 1: Expected list type
            if (expected != null && expected.type == NPType.LIST) {
                const subtype = expected.subtype;

                let matchesExpected = true;
                for (let i = 0; i < npvec.size(nodes); i += 1) {
                    const node = npvec.at(nodes, i);
                    const nodeType = res.register(visit(node));
                    if (res.hasError())
                        continue;
                    
                    if (!nodeType.canUpcast(subtype))
                        matchesExpected = false;
                }

                if (res.hasError())
                    return res;
                
                if (matchesExpected)
                    return res.success(expected);
            }

            // Case 2: Matching list element types
            if (npvec.size(nodes) > 0) {
                const nodes = node.getChildren();
                const subtype = res.register(visit(npvec.at(nodes, 0)));
                if (res.hasError())
                    return res;

                let matchesExpected = true;
                for (let i = 1; i < npvec.size(nodes); i += 1) {
                    const node = npvec.at(nodes, i);
                    const nodeType = res.register(visit(node));
                    if (res.hasError())
                        continue;
                    
                    if (nodeType != subtype)
                        matchesExpected = false;
                }

                if (res.hasError())
                    return res;
                
                if (matchesExpected)
                    return res.success(NPList(subtype));
            }
            
            // Case 3: Empty list or default for other cases
            return res.success(NPList(NPAny.get()));
        }

        // Operations [ ]
        else if (nodeType == NodeType.CAST) {
            return typeLookup(node.getCastType());
        }
        else if (nodeType == NodeType.BINARY) {
            const res = TypeResult();
            const leftType = res.register(visit(node.getLeft()));
            const rightType = res.register(visit(node.getRight()));

            if (res.hasError())
                return res;
            
            const opcode = TypeOperations.fromOpcode(node.getOpcode());
            const operation = leftType.operation(opcode);
            const outType = operation(npvec.vec(rightType), 1);
            if (outType.type == NPType.ERROR)
                return res.typeFailure(outType, node.getRight());
            return res.success(outType);
        }
        else if (nodeType == NodeType.UNARY) {
            const res = TypeResult();
            const opType = res.register(visit(node.getOperand()));

            if (res.hasError())
                return res;
            
            const opcode = TypeOperations.fromOpcode(node.getOpcode());
            const operation = opType.operation(opcode);
            const outType = operation(npvec.vec(), 0);
            if (outType.type == NPType.ERROR)
                return res.typeFailure(outType, node.getOperand());
            return res.success(outType);
        }
        else if (nodeType == NodeType.CALL) {
            const res = TypeResult();

        }

        // Variables [ ]

        // Functions [ ]

        // Control Flow [ ]
        
        // Classes

        return TypeResult().success(NPVoid.get());
    }

    func prv typeLookup(unres) {
        return TypeResult().success(rootPackage.typeLookup(unres));
    }

    func prv addDependency(var) {
        for (let i = 0; i < functionDepth; i += 1) {

        }
    }

    func prv getTypedVariable(name) {
        for (let i = scopeDepth - 1; i >= 0; i += 1) {
            const localScope = npvec.at(localStack, i);
            if (npmap.has(localScope, name))
                return npmap.get(localScope, name);
        }

        if (npmap.has(globals, name)) {
            const typedVariable = npmap.get(globals, name);

            addDependency(typedVariable);
            
            return typedVariable;
        }
        
        addDependency(TypedVariable(name, null));
        return null;
    }
}
